# 问题简介

[LeetCode 101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给你一个二叉树的根节点 `root`，检查它是否轴对称。

## 示例说明

### 示例 1：

```
输入：root = [1,2,2,3,4,4,3]
输出：true
```

![示例1](https://assets.leetcode.com/uploads/2021/02/19/symtree1.jpg)

### 示例 2：

```
输入：root = [1,2,2,null,3,null,3]
输出：false
```

![示例2](https://assets.leetcode.com/uploads/2021/02/19/symtree2.jpg)

### 提示：

- 树中节点数目在范围 `[1, 1000]` 内
- `-100 <= Node.val <= 100`

______________________________________________________________________

# 解题思路

## 方法一：递归法（推荐）✅

💡 **核心思想**：一棵二叉树是对称的，当且仅当它的左子树和右子树互为镜像。

### 步骤分析：

1. **定义递归函数**：`isMirror(left, right)` 判断两个子树是否互为镜像
1. **递归终止条件**：
   - 如果两个节点都为空 → 对称 ✅
   - 如果其中一个为空，另一个不为空 → 不对称 ❌
   - 如果两个节点值不相等 → 不对称 ❌
1. **递归关系**：
   - 左子树的左孩子 与 右子树的右孩子 对称
   - 左子树的右孩子 与 右子树的左孩子 对称

### 递归逻辑：

```
isMirror(left, right) = 
    (left == null && right == null) ||
    (left != null && right != null && 
     left.val == right.val && 
     isMirror(left.left, right.right) && 
     isMirror(left.right, right.left))
```

## 方法二：迭代法（使用队列）✅

💡 **核心思想**：使用队列模拟递归过程，逐层比较对称位置的节点。

### 步骤分析：

1. **初始化队列**：将根节点的左右子节点加入队列
1. **循环处理**：
   - 从队列中取出两个节点进行比较
   - 如果都为空，继续下一轮
   - 如果一个为空或值不等，返回 false
   - 将对应的对称子节点按顺序加入队列：
     - `left.left` 和 `right.right`
     - `left.right` 和 `right.left`
1. **队列为空时**：说明所有对称位置都匹配，返回 true

## 方法对比

| 方法 | 时间复杂度 | 空间复杂度 | 代码简洁度 | 理解难度 |
|------|------------|------------|------------|----------|
| 递归法 | O(n) | O(h) | ⭐⭐⭐⭐⭐ | ⭐⭐ |
| 迭代法 | O(n) | O(n) | ⭐⭐⭐ | ⭐⭐⭐ |

> 📌 **h 为树的高度，n 为节点总数**

______________________________________________________________________

# 代码实现

<div class="code-tabs">

```java:Java
// 方法一：递归法
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        return isMirror(root.left, root.right);
    }
    
    private boolean isMirror(TreeNode left, TreeNode right) {
        // 两个都为空，对称
        if (left == null && right == null) {
            return true;
        }
        // 一个为空，一个不为空，不对称
        if (left == null || right == null) {
            return false;
        }
        // 值不相等，不对称
        if (left.val != right.val) {
            return false;
        }
        // 递归检查：左子树的左孩子 vs 右子树的右孩子
        //           左子树的右孩子 vs 右子树的左孩子
        return isMirror(left.left, right.right) && 
               isMirror(left.right, right.left);
    }
}

// 方法二：迭代法
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) {
            return true;
        }
        
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root.left);
        queue.offer(root.right);
        
        while (!queue.isEmpty()) {
            TreeNode left = queue.poll();
            TreeNode right = queue.poll();
            
            // 两个都为空，继续
            if (left == null && right == null) {
                continue;
            }
            // 一个为空或值不等
            if (left == null || right == null || left.val != right.val) {
                return false;
            }
            
            // 按对称顺序加入队列
            queue.offer(left.left);
            queue.offer(right.right);
            queue.offer(left.right);
            queue.offer(right.left);
        }
        
        return true;
    }
}
```

```go:Go
// 方法一：递归法
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    return isMirror(root.Left, root.Right)
}

func isMirror(left, right *TreeNode) bool {
    // 两个都为空，对称
    if left == nil && right == nil {
        return true
    }
    // 一个为空，一个不为空，不对称
    if left == nil || right == nil {
        return false
    }
    // 值不相等，不对称
    if left.Val != right.Val {
        return false
    }
    // 递归检查对称位置
    return isMirror(left.Left, right.Right) && 
           isMirror(left.Right, right.Left)
}

// 方法二：迭代法
func isSymmetric(root *TreeNode) bool {
    if root == nil {
        return true
    }
    
    queue := []*TreeNode{root.Left, root.Right}
    
    for len(queue) > 0 {
        left := queue[0]
        right := queue[1]
        queue = queue[2:]
        
        // 两个都为空，继续
        if left == nil && right == nil {
            continue
        }
        // 一个为空或值不等
        if left == nil || right == nil || left.Val != right.Val {
            return false
        }
        
        // 按对称顺序加入队列
        queue = append(queue, left.Left, right.Right, left.Right, right.Left)
    }
    
    return true
}
```

</div>

______________________________________________________________________

# 示例演示

## 示例 1 演示：`[1,2,2,3,4,4,3]`

```
       1
      / \
     2   2
    / \ / \
   3  4 4  3
```

**递归调用过程**：

1. `isMirror(2, 2)` → 值相等
1. `isMirror(3, 3)` → 值相等，且都为叶子节点 → true
1. `isMirror(4, 4)` → 值相等，且都为叶子节点 → true
1. 最终返回 true ✅

## 示例 2 演示：`[1,2,2,null,3,null,3]`

```
       1
      / \
     2   2
      \   \
       3   3
```

**递归调用过程**：

1. `isMirror(2, 2)` → 值相等
1. `isMirror(null, null)` → true（左子树的左 vs 右子树的右）
1. `isMirror(3, 3)` → 值相等
1. 但是结构上：左子树只有右孩子，右子树只有右孩子
1. 实际上在第二层比较时：`left.left = null`, `right.right = null` ✅
1. `left.right = 3`, `right.left = null` ❌ → 返回 false

> 💡 **注意**：示例2的关键在于右子树的左孩子是 null，而左子树的右孩子是 3

______________________________________________________________________

# 答案有效性证明

## 正确性证明

### 充分性证明：

如果算法返回 `true`，那么二叉树一定是对称的。

- 递归法确保了每个对称位置的节点值都相等
- 所有对应位置的结构都一致（同时为空或同时存在）

### 必要性证明：

如果二叉树是对称的，那么算法一定返回 `true`。

- 对称二叉树的定义就是左右子树互为镜像
- 算法正好按照镜像的定义进行验证

### 边界情况覆盖：

- ✅ 空树：返回 true
- ✅ 单节点：返回 true
- ✅ 完全不对称：正确返回 false
- ✅ 值相同但结构不同：正确返回 false

______________________________________________________________________

# 复杂度分析

## 时间复杂度：O(n)

- 需要访问树中的每个节点恰好一次
- n 为二叉树的节点总数

## 空间复杂度：

### 递归法：O(h)

- h 为树的高度
- 最坏情况（链状树）：O(n)
- 最好情况（完全平衡树）：O(log n)

### 迭代法：O(n)

- 队列最多存储一层的所有节点
- 最坏情况下（完全二叉树的最后一层）：约 n/2 个节点
- 因此空间复杂度为 O(n)

______________________________________________________________________

# 问题总结

## 📌 关键要点

1. **对称的本质**：左子树和右子树互为镜像
1. **递归思维**：将大问题分解为相同的子问题
1. **边界处理**：空节点的处理是关键
1. **对称配对**：`left.left` ↔ `right.right`，`left.right` ↔ `right.left`

## 💡 解题技巧

- **画图理解**：对称问题一定要画图，直观理解对称关系
- **递归模板**：树的对称、相同、翻转等问题都有相似的递归模式
- **测试用例**：特别注意结构相同但值不同的情况，以及值相同但结构不同的情况

## ✅ 推荐方案

**优先使用递归法**，因为：

- 代码简洁易懂
- 空间效率更高（平均情况下）
- 符合树的天然递归结构

这个问题是理解二叉树递归操作的经典例题，掌握后可以轻松应对类似的树结构比较问题。
