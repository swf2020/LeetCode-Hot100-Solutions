# 问题简介

[LeetCode 104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定一个二叉树 `root`，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

______________________________________________________________________

# 示例说明

✅ **示例 1：**

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

✅ **示例 2：**

```
输入：root = [1,null,2]
输出：2
```

✅ **示例 3：**

```
输入：root = []
输出：0
```

✅ **示例 4：**

```
输入：root = [0]
输出：1
```

______________________________________________________________________

# 解题思路

📌 **核心思想**：求二叉树的最大深度，本质上是遍历整棵树并记录从根到叶的最长路径长度。

## 方法一：递归（深度优先搜索 DFS）

💡 **思路步骤**：

1. 如果当前节点为空，返回深度 0。
1. 否则，分别递归计算左子树和右子树的最大深度。
1. 当前节点的最大深度 = `max(左子树深度, 右子树深度) + 1`。
1. 返回该值。

✅ **优点**：代码简洁，逻辑清晰。\
❌ **缺点**：在极端不平衡树（如链表）时，递归栈可能溢出（但在 LeetCode 测试用例中通常不会）。

______________________________________________________________________

## 方法二：迭代（广度优先搜索 BFS / 层序遍历）

💡 **思路步骤**：

1. 使用队列进行层序遍历。
1. 每处理完一层，深度 +1。
1. 当队列为空时，返回累计的深度。

✅ **优点**：避免递归栈溢出，适合非常深的树。\
❌ **缺点**：需要额外的队列空间。

______________________________________________________________________

## 方法三：迭代（DFS + 栈模拟）

💡 **思路**：用显式栈模拟递归过程，每个栈元素保存 `(节点, 当前深度)`。

1. 初始化栈，压入 `(root, 1)`（若 root 非空）。
1. 循环弹出栈顶，更新最大深度。
1. 若有左右子节点，将其与 `depth + 1` 一起压入栈。
1. 返回最大深度。

✅ **优点**：可控栈深度，避免系统递归限制。\
❌ **缺点**：代码略复杂。

> 📌 **本题最常用、最推荐的是方法一（递归 DFS）**，因其简洁高效。

______________________________________________________________________

# 代码实现

<div class="code-tabs">

```java:Java
// 方法一：递归 DFS
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}

// 方法二：BFS 层序遍历
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int depth = 0;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            // 处理当前层所有节点
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
            depth++;
        }
        return depth;
    }
}
```

```go:Go
// 方法一：递归 DFS
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    leftDepth := maxDepth(root.Left)
    rightDepth := maxDepth(root.Right)
    return max(leftDepth, rightDepth) + 1
}

// 辅助函数（Go 1.21+ 可用内置 max，否则需自定义）
func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

// 方法二：BFS 层序遍历
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
    queue := []*TreeNode{root}
    depth := 0
    
    for len(queue) > 0 {
        size := len(queue)
        for i := 0; i < size; i++ {
            node := queue[0]
            queue = queue[1:]
            if node.Left != nil {
                queue = append(queue, node.Left)
            }
            if node.Right != nil {
                queue = append(queue, node.Right)
            }
        }
        depth++
    }
    return depth
}
```

</div>

______________________________________________________________________

# 示例演示

以 `root = [3,9,20,null,null,15,7]` 为例：

```
      3
     / \
    9  20
      /  \
     15   7
```

- 递归过程：
  - `maxDepth(3)` → `max(maxDepth(9), maxDepth(20)) + 1`
  - `maxDepth(9)` → `max(0, 0) + 1 = 1`
  - `maxDepth(20)` → `max(maxDepth(15), maxDepth(7)) + 1 = max(1,1)+1 = 2`
  - 最终：`max(1, 2) + 1 = 3`

✅ 输出：`3`，符合预期。

______________________________________________________________________

# 答案有效性证明

📌 **数学归纳法**：

- **基础情况**：空树深度为 0，单节点树深度为 1，成立。
- **归纳假设**：假设对所有节点数小于 n 的二叉树，算法正确。
- **归纳步骤**：对于 n 个节点的树，根节点的左右子树节点数均小于 n，由归纳假设，左右子树深度计算正确。取较大值 +1 即为整棵树深度。

✅ 因此，递归解法正确。

📌 **BFS 正确性**：

- 每次 while 循环处理一层，depth 计数即为层数，而二叉树深度 = 层数。
- 队列确保按层遍历，无遗漏。

✅ BFS 解法同样正确。

______________________________________________________________________

# 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 递归 DFS | `O(n)` | `O(h)` | `n` 为节点数，`h` 为树高（最坏 O(n)，最好 O(log n)） |
| BFS 迭代 | `O(n)` | `O(w)` | `w` 为树的最大宽度（最坏 O(n)，如完全二叉树最后一层） |
| DFS 栈模拟 | `O(n)` | `O(h)` | 同递归，但使用显式栈 |

> ✅ 所有方法时间复杂度均为 `O(n)`，因为必须访问每个节点一次。

______________________________________________________________________

# 问题总结

✅ **关键点回顾**：

- 二叉树最大深度 = 根到最远叶节点的路径长度（节点数）。
- 递归是最直观、简洁的解法，体现“分治”思想。
- BFS 提供了一种非递归、按层处理的视角，适用于栈空间受限场景。
- 两种主流方法各有适用场景，但本题中递归更优。

💡 **延伸思考**：

- 若求**最小深度**（到最近叶节点），递归逻辑需调整（不能简单取 min，需处理单子树情况）。
- 此题是树遍历的基础模板，掌握后可推广至更多树形 DP 问题。

📌 **一句话总结**：**“树的最大深度 = 1 + max(左子树深度, 右子树深度)” —— 递归之美！**
