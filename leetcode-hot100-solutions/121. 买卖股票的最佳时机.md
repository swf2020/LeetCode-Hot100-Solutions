# 问题简介

[121. 买卖股票的最佳时机 - LeetCode](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定一个数组 `prices`，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。

你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0`。

______________________________________________________________________

## 示例说明

✅ **示例 1：**

```
输入：[7,1,5,3,6,4]
输出：5
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5。
     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
```

✅ **示例 2：**

```
输入：prices = [7,6,4,3,1]
输出：0
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。
```

______________________________________________________________________

## 解题思路

### 💡 方法一：一次遍历（贪心思想）

这是最高效、最直观的解法。

**核心思想：**

- 在遍历过程中，记录到目前为止遇到的**最低价格**（即最佳买入点）。
- 同时，计算如果**今天卖出**能获得的利润（当前价格 - 最低价格）。
- 不断更新**最大利润**。

**步骤：**

1. 初始化 `minPrice = prices[0]`，`maxProfit = 0`。
1. 从第 1 天开始遍历：
   - 如果 `prices[i] < minPrice`，更新 `minPrice = prices[i]`。
   - 否则，计算 `profit = prices[i] - minPrice`，并更新 `maxProfit = max(maxProfit, profit)`。
1. 返回 `maxProfit`。

> ✅ 为什么正确？\
> 因为我们始终保证“买入”发生在“卖出”之前（`minPrice` 是历史最低），且我们尝试了所有可能的卖出日，取最大值。

______________________________________________________________________

### ❌ 方法二：暴力法（不推荐）

双重循环：对每个买入日 i，遍历所有 j > i 的卖出日，计算利润，取最大值。

- 时间复杂度：O(n²)
- 空间复杂度：O(1)
- 对于 n 较大时会超时（LeetCode 测试用例会卡住）

______________________________________________________________________

### 💡 方法三：动态规划（可扩展性强）

虽然本题用贪心更优，但 DP 思路有助于理解后续变种题（如多次交易、含手续费等）。

**状态定义：**

- `dp[i][0]`：第 i 天**不持有**股票的最大利润
- `dp[i][1]`：第 i 天**持有**股票的最大利润

**状态转移：**

- `dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])`\
  （继续不持 or 卖出）
- `dp[i][1] = max(dp[i-1][1], -prices[i])`\
  （继续持有 or 第一次买入，因为只能交易一次）

**初始化：**

- `dp[0][0] = 0`
- `dp[0][1] = -prices[0]`

**结果：** `dp[n-1][0]`

> ⚠️ 注意：由于只能交易一次，买入时的利润是 `-prices[i]`，而不是 `dp[i-1][0] - prices[i]`（因为之前没交易过，现金为 0）。

______________________________________________________________________

## 代码实现

```java
// 方法一：一次遍历（推荐）
class Solution {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        
        int minPrice = prices[0];
        int maxProfit = 0;
        
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] < minPrice) {
                minPrice = prices[i];
            } else {
                maxProfit = Math.max(maxProfit, prices[i] - minPrice);
            }
        }
        
        return maxProfit;
    }
}

// 方法三：动态规划（可选）
class SolutionDP {
    public int maxProfit(int[] prices) {
        if (prices == null || prices.length == 0) return 0;
        
        int n = prices.length;
        int[][] dp = new int[n][2];
        
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        
        for (int i = 1; i < n; i++) {
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]); // 只能买一次
        }
        
        return dp[n-1][0];
    }
}
```

```go
// 方法一：一次遍历（推荐）
func maxProfit(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    
    minPrice := prices[0]
    maxProfit := 0
    
    for i := 1; i < len(prices); i++ {
        if prices[i] < minPrice {
            minPrice = prices[i]
        } else {
            profit := prices[i] - minPrice
            if profit > maxProfit {
                maxProfit = profit
            }
        }
    }
    
    return maxProfit
}

// 方法三：动态规划（可选）
func maxProfitDP(prices []int) int {
    if len(prices) == 0 {
        return 0
    }
    
    n := len(prices)
    dp := make([][2]int, n)
    
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    
    for i := 1; i < n; i++ {
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = max(dp[i-1][1], -prices[i])
    }
    
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

______________________________________________________________________

## 示例演示

📌 以 `prices = [7,1,5,3,6,4]` 为例：

| 天数 i | price | minPrice | 当日利润 | maxProfit |
|--------|-------|----------|----------|-----------|
| 0 | 7 | 7 | - | 0 |
| 1 | 1 | **1** | - | 0 |
| 2 | 5 | 1 | 4 | **4** |
| 3 | 3 | 1 | 2 | 4 |
| 4 | 6 | 1 | **5** | **5** |
| 5 | 4 | 1 | 3 | 5 |

✅ 最终 `maxProfit = 5`

______________________________________________________________________

## 答案有效性证明

**贪心策略的正确性：**

- 设最优解为在第 `b` 天买入，第 `s` 天卖出（`b < s`），利润为 `P = prices[s] - prices[b]`。
- 在遍历到第 `s` 天时，`minPrice` 一定 ≤ `prices[b]`（因为 `b < s`，且我们记录了历史最低）。
- 因此，算法在第 `s` 天计算的利润 ≥ `prices[s] - prices[b] = P`。
- 而算法取的是所有可能卖出日的最大利润，故结果 ≥ 最优解。
- 又因算法只考虑合法交易（买入在卖出前），结果 ≤ 最优解。
- 所以，算法结果 = 最优解。

______________________________________________________________________

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------------|------------|------------|--------------------------|
| 一次遍历 | O(n) | O(1) | ✅ 最优解 |
| 暴力法 | O(n²) | O(1) | ❌ 超时 |
| 动态规划 | O(n) | O(n) | 可优化为 O(1)（滚动数组）|

> 💡 实际上，DP 方法可以优化空间：
>
> ```java
> int hold = -prices[0], sold = 0;
> for (int i = 1; i < n; i++) {
>     sold = Math.max(sold, hold + prices[i]);
>     hold = Math.max(hold, -prices[i]);
> }
> return sold;
> ```

______________________________________________________________________

## 问题总结

- ✅ **核心洞察**：最大利润 = 最高卖出价 - 最低买入价，且买入必须在卖出之前。
- ✅ **最优解法**：一次遍历维护历史最低价，实时更新最大利润。
- 💡 **扩展思考**：此题是股票系列的基础，后续题目（如多次交易、冷冻期、手续费）多基于 DP 状态机模型。
- 📌 **关键技巧**：不要试图找“最高价和最低价”，而要找“**在最低价之后出现的最高价**”。

> 掌握此题的贪心思想与 DP 建模，是攻克 LeetCode 股票系列问题的第一步！
