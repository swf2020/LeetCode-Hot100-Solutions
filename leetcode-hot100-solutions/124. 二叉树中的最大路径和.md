# 二叉树中的最大路径和

## 问题简介

[LeetCode 124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum?envType=problem-list-v2&envId=2cktkvj)

### 题目描述

路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。

路径和 是路径中各节点值的总和。

给你一个二叉树的根节点 `root` ，返回其 最大路径和 。

## 示例说明

### 示例 1

```
输入：root = [1,2,3]
输出：6
解释：最优路径是 2 -> 1 -> 3 ，路径和为 2 + 1 + 3 = 6
```

### 示例 2

```
输入：root = [-10,9,20,null,null,15,7]
输出：42
解释：最优路径是 15 -> 20 -> 7 ，路径和为 15 + 20 + 7 = 42
```

## 解题思路

### ✅ 核心思想：后序遍历 + 全局最大值维护

这个问题的关键在于理解**路径的定义**：

- 路径可以从任意节点开始，到任意节点结束
- 路径不能分叉（即不能同时走左右子树然后向上）
- 但计算最大路径时，可以考虑以当前节点为"顶点"的路径（左->当前->右）

### 📌 解题步骤

1. **定义递归函数**：`maxGain(node)` 返回以当前节点为起点，向下延伸的最大路径和
1. **处理空节点**：返回 0
1. **递归计算左右子树**：获取左右子树的最大贡献值
1. **计算当前节点作为路径顶点的情况**：
   - 路径和 = node.val + max(0, leftGain) + max(0, rightGain)
   - 更新全局最大值
1. **返回当前节点的最大贡献值**：
   - 只能选择左子树或右子树中的一个（因为路径不能分叉）
   - 返回 node.val + max(0, max(leftGain, rightGain))

### 💡 为什么需要 max(0, ...)？

因为如果子树的贡献值为负数，我们完全可以不选择该子树，只取当前节点本身。

### ❌ 常见错误思路

- **错误1**：认为最大路径一定经过根节点
- **错误2**：在返回值时同时加上左右子树的贡献（这样会形成分叉路径）
- **错误3**：没有考虑负数情况，直接相加

## 代码实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private int maxSum = Integer.MIN_VALUE;
    
    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }
    
    private int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 递归计算左右子树的最大贡献值
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);
        
        // 计算以当前节点为顶点的路径和
        int currentPathSum = node.val + leftGain + rightGain;
        
        // 更新全局最大值
        maxSum = Math.max(maxSum, currentPathSum);
        
        // 返回当前节点的最大贡献值（只能选择一边）
        return node.val + Math.max(leftGain, rightGain);
    }
}
````

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func maxPathSum(root *TreeNode) int {
    maxSum := math.MinInt32
    
    var maxGain func(*TreeNode) int
    maxGain = func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        
        // 递归计算左右子树的最大贡献值
        leftGain := max(maxGain(node.Left), 0)
        rightGain := max(maxGain(node.Right), 0)
        
        // 计算以当前节点为顶点的路径和
        currentPathSum := node.Val + leftGain + rightGain
        
        // 更新全局最大值
        maxSum = max(maxSum, currentPathSum)
        
        // 返回当前节点的最大贡献值（只能选择一边）
        return node.Val + max(leftGain, rightGain)
    }
    
    maxGain(root)
    return maxSum
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## 示例演示

### 示例 1 演示：`[1,2,3]`

```
 1
/ \
2 3

```

| 节点 | leftGain | rightGain | currentPathSum | maxSum更新 | 返回值 |
|------|----------|-----------|----------------|------------|--------|
| 2    | 0        | 0         | 2              | 2          | 2      |
| 3    | 0        | 0         | 3              | 3          | 3      |
| 1    | 2        | 3         | 6              | 6          | 4      |

最终结果：6 ✅

### 示例 2 演示：`[-10,9,20,null,null,15,7]`


```
 -10
 / \
9  20
  /  \
 15   7
```



关键计算步骤：
- 节点15：返回15，currentPathSum=15
- 节点7：返回7，currentPathSum=7  
- 节点20：leftGain=15, rightGain=7, currentPathSum=42, 返回35
- 节点9：返回9，currentPathSum=9
- 节点-10：leftGain=9, rightGain=35, currentPathSum=34, 返回25

全局最大值为42 ✅

## 答案有效性证明

### ✅ 正确性分析

1. **覆盖所有可能路径**：
   - 对于任意路径，必然存在一个最高点（顶点）
   - 我们的算法在每个节点都计算了以其为顶点的最大路径和
   - 因此覆盖了所有可能的路径情况

2. **路径约束满足**：
   - 返回值只选择左或右子树，保证了路径的连续性
   - 计算顶点路径时虽然用了左右子树，但这代表的是完整的路径，不是用于向上返回的

3. **边界情况处理**：
   - 空节点返回0，不影响计算
   - 负数通过max(0, gain)自动被忽略
   - 单节点情况正确处理

### 📌 数学归纳法证明

**基础情况**：单节点树，算法正确返回该节点值

**归纳假设**：对于高度小于h的树，算法正确

**归纳步骤**：对于高度为h的树，根节点的左右子树高度都小于h，根据归纳假设，左右子树的最大贡献值计算正确。根节点作为顶点的路径和计算正确，且返回的最大贡献值也正确。

## 复杂度分析

| 复杂度类型 | 时间复杂度 | 空间复杂度 |
|------------|------------|------------|
| **分析** | O(N) | O(H) |
| **说明** | 每个节点访问一次 | 递归栈深度，H为树的高度 |

- **最好情况**：完全平衡树，H = log N，空间复杂度 O(log N)
- **最坏情况**：退化为链表，H = N，空间复杂度 O(N)

## 问题总结

### 💡 关键洞察
- **路径顶点概念**：任何路径都有唯一的最高点（顶点）
- **贡献值 vs 路径和**：向上传递的是贡献值（单向），计算的是路径和（双向）
- **负数处理**：负贡献可以直接舍弃

### 📌 解题模式
这道题体现了**树形DP**的经典模式：
1. 后序遍历确保子问题先解决
2. 维护全局最优解
3. 返回局部最优解用于上层计算

### ✅ 扩展思考
- 如果要求返回具体的路径而不是路径和，如何修改？
- 如果路径必须经过根节点，问题会变得简单很多
- 这种"顶点"思想可以应用到其他树路径问题中

掌握这种思维方式，类似的树路径问题就能迎刃而解！
