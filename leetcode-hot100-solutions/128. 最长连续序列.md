# ❌|✅|💡|📌 128. 最长连续序列

## 🔗 问题简介

[LeetCode 128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence?envType=problem-list-v2&envId=2cktkvj)

### 题目描述

给定一个未排序的整数数组 `nums`，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

______________________________________________________________________

## 📌 示例说明

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
解释：最长连续序列为 [0,1,2,3,4,5,6,7,8]，长度为 9。
```

**示例 3：**

```
输入：nums = []
输出：0
```

______________________________________________________________________

## 💡 解题思路

### ✅ 方法一：哈希集合 + 跳跃起点判断（推荐）

**核心思想：**

- 使用 `Set` 存储所有数字，实现 O(1) 查找。
- 对于每个数字 `num`，只有当 `num - 1` **不在**集合中时，才将其视为一个连续序列的**起点**。
- 从起点开始，不断检查 `num + 1`, `num + 2`, ... 是否在集合中，统计当前序列长度。
- 记录所有序列中的最大长度。

**为什么这样能保证 O(n)？**

- 每个数字最多被访问两次：一次作为普通元素加入 set，一次作为序列起点或中间元素被遍历。
- 关键在于“只从起点开始遍历”，避免了重复扫描。

______________________________________________________________________

### ❌ 方法二：排序后遍历（不符合 O(n) 要求）

- 先对数组排序（O(n log n)）
- 然后线性扫描，记录连续递增序列长度
- 虽然简单，但时间复杂度不满足题目要求

> ⚠️ 题目明确要求 O(n)，因此此方法仅作对比，不推荐。

______________________________________________________________________

### ❌ 方法三：并查集（Union-Find）

- 将每个数字视为节点，若存在 `x` 和 `x+1`，则合并
- 最终找最大连通分量大小
- 实现复杂，且常数较大，不如方法一简洁高效

______________________________________________________________________

## 💻 代码实现

<div class="code-tabs">

```java:Java
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }

        int maxLength = 0;
        for (int num : numSet) {
            // 只有当 num 是序列起点时才开始计数
            if (!numSet.contains(num - 1)) {
                int currentNum = num;
                int currentLength = 1;

                while (numSet.contains(currentNum + 1)) {
                    currentNum++;
                    currentLength++;
                }

                maxLength = Math.max(maxLength, currentLength);
            }
        }

        return maxLength;
    }
}
```

```go:Go
func longestConsecutive(nums []int) int {
    numSet := make(map[int]bool)
    for _, num := range nums {
        numSet[num] = true
    }

    maxLength := 0
    for num := range numSet {
        // 只有当 num 是序列起点时才开始计数
        if !numSet[num-1] {
            currentNum := num
            currentLength := 1

            for numSet[currentNum+1] {
                currentNum++
                currentLength++
            }

            if currentLength > maxLength {
                maxLength = currentLength
            }
        }
    }

    return maxLength
}
```

</div>

______________________________________________________________________

## 🧪 示例演示

以 `nums = [100,4,200,1,3,2]` 为例：

1. 构建 set: `{100, 4, 200, 1, 3, 2}`
1. 遍历每个元素：
   - `100`：检查 `99` 不存在 → 是起点 → 序列 `[100]`，长度 1
   - `4`：检查 `3` 存在 → 跳过
   - `200`：检查 `199` 不存在 → 是起点 → 序列 `[200]`，长度 1
   - `1`：检查 `0` 不存在 → 是起点 → 序列 `[1,2,3,4]`，长度 4 ✅
   - `3`：检查 `2` 存在 → 跳过
   - `2`：检查 `1` 存在 → 跳过
1. 最大长度 = 4

______________________________________________________________________

## ✅ 答案有效性证明

**正确性：**

- 所有连续序列都有唯一最小值（起点）
- 算法确保每个序列仅从其起点开始遍历一次
- 不会遗漏任何序列，也不会重复计算

**边界情况处理：**

- 空数组 → 返回 0
- 单元素 → 返回 1
- 重复元素 → Set 自动去重，不影响结果

______________________________________________________________________

## 📊 复杂度分析

| 项目 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 哈希集合法 | **O(n)** | **O(n)** |

- **时间**：每个元素最多被访问两次（一次入 set，一次在 while 循环中），总操作数 ≤ 2n → O(n)
- **空间**：哈希集合存储 n 个元素 → O(n)

> 排序法：O(n log n) 时间，O(1) 空间（若允许修改原数组）

______________________________________________________________________

## 📌 问题总结

- **关键洞察**：连续序列有唯一最小值，只从最小值开始扩展可避免重复工作
- **数据结构选择**：哈希集合提供 O(1) 查找，是实现 O(n) 的关键
- **面试高频点**：考察对“跳过非起点”这一优化的理解
- **易错点**：
  - 忘记去重（重复元素不影响逻辑，但 set 自动处理）
  - 未判断起点，导致 O(n²) 时间复杂度

> 💡 **记忆口诀**：“只从谷底爬山，不走回头路” —— 谷底即 `num - 1` 不存在的点。
