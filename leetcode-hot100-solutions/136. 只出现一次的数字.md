# ❌|✅|💡|📌 136. 只出现一次的数字

## 🔗 问题简介

[LeetCode 136. 只出现一次的数字](https://leetcode.cn/problems/single-number?envType=problem-list-v2&envId=2cktkvj)

### 题目描述

给你一个 **非空** 整数数组 `nums`，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

______________________________________________________________________

## 📌 示例说明

**示例 1：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

**示例 3：**

```
输入：nums = [1]
输出：1
```

______________________________________________________________________

## 💡 解题思路

### 方法一：异或（XOR）运算法 ✅（最优解）

利用异或运算的性质：

- `a ^ a = 0`
- `a ^ 0 = a`
- 异或满足交换律和结合律

因此，将数组中所有元素进行异或，成对出现的元素会相互抵消为 0，最终结果就是只出现一次的那个数。

**步骤：**

1. 初始化结果变量 `res = 0`
1. 遍历数组，对每个元素执行 `res ^= num`
1. 返回 `res`

### 方法二：哈希表法 ❌（不符合空间要求）

使用哈希表统计每个数字出现的次数，最后找出出现次数为 1 的数字。

**缺点：** 空间复杂度为 O(n)，不符合题目“常量额外空间”的要求。

### 方法三：数学法（求和）❌（有局限性）

计算 `2 * 所有唯一数字之和 - 所有数字之和`。

**缺点：**

- 需要额外空间存储唯一数字集合
- 可能存在整数溢出问题

______________________________________________________________________

## 💻 代码实现

```java
class Solution {
    public int singleNumber(int[] nums) {
        int res = 0;
        for (int num : nums) {
            res ^= num;
        }
        return res;
    }
}
```

```go
func singleNumber(nums []int) int {
    res := 0
    for _, num := range nums {
        res ^= num
    }
    return res
}
```

______________________________________________________________________

## 🎯 示例演示

以 `nums = [4,1,2,1,2]` 为例：

```
初始: res = 0
0 ^ 4 = 4
4 ^ 1 = 5
5 ^ 2 = 7
7 ^ 1 = 6
6 ^ 2 = 4
最终结果: 4
```

异或过程可以重新排列为：`4 ^ (1 ^ 1) ^ (2 ^ 2) = 4 ^ 0 ^ 0 = 4`

______________________________________________________________________

## ✅ 答案有效性证明

**数学归纳法证明：**

**基础情况：** 当数组只有一个元素时，该元素就是答案，算法返回正确结果。

**归纳假设：** 假设对于长度为 2k+1 的数组（k≥0），算法能正确找到唯一元素。

**归纳步骤：** 对于长度为 2(k+1)+1 = 2k+3 的数组，由于其他元素都成对出现，异或运算的交换律和结合律保证了成对元素可以相邻计算得到 0，最终只剩下唯一元素。

**异或性质保证：**

- 相同数字异或为 0
- 任何数与 0 异或等于自身
- 运算顺序不影响最终结果

因此，算法在所有情况下都能正确工作。

______________________________________________________________________

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 是否符合要求 |
|------|------------|------------|--------------|
| 异或法 | O(n) | O(1) | ✅ |
| 哈希表法 | O(n) | O(n) | ❌ |
| 数学法 | O(n) | O(n) | ❌ |

**异或法详细分析：**

- **时间复杂度：** O(n) - 需要遍历数组一次
- **空间复杂度：** O(1) - 只使用一个额外变量

______________________________________________________________________

## 📝 问题总结

- **核心洞察：** 利用异或运算的自反性和恒等性
- **关键性质：** `a ^ a = 0` 和 `a ^ 0 = a`
- **算法优势：** 时间和空间复杂度都达到理论最优
- **适用场景：** 找出数组中唯一不重复的元素（其他元素恰好重复偶数次）
- **扩展思考：** 如果其他元素重复 3 次，需要使用其他方法（如位计数）
