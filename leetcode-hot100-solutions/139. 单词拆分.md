# 单词拆分（LeetCode 139）

📌 **问题简介**\
🔗 [LeetCode 139. 单词拆分](https://leetcode.cn/problems/word-break?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。请你判断是否可以利用字典中出现的一个或多个单词拼接出 `s`。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

______________________________________________________________________

## 示例说明

✅ **示例 1：**\
输入: `s = "leetcode"`, `wordDict = ["leet", "code"]`\
输出: `true`\
解释: 返回 true，因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

✅ **示例 2：**\
输入: `s = "applepenapple"`, `wordDict = ["apple", "pen"]`\
输出: `true`\
解释: 返回 true，因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。

❌ **示例 3：**\
输入: `s = "catsandog"`, `wordDict = ["cats", "dog", "sand", "and", "cat"]`\
输出: `false`

______________________________________________________________________

## 解题思路

### 💡 方法一：动态规划（推荐）

这是最经典、最高效的解法。

#### 步骤如下：

1. **定义状态**：\
   `dp[i]` 表示字符串 `s` 的前 `i` 个字符（即 `s[0:i]`）是否可以被字典中的单词拼接而成。

1. **初始化**：\
   `dp[0] = true`（空字符串可以被拼接）。

1. **状态转移**：\
   对于每个位置 `i`（从 1 到 n），遍历所有 `j < i`：

   - 如果 `dp[j] == true` 且子串 `s[j:i]` 在字典中，则 `dp[i] = true`。

1. **结果**：\
   返回 `dp[n]`，其中 `n = s.length()`。

> ✅ 优化：将 `wordDict` 转为 `HashSet`，使查找时间复杂度为 O(1)。

______________________________________________________________________

### 💡 方法二：记忆化回溯（DFS + Memo）

从字符串开头开始尝试匹配字典中的单词，若匹配成功则递归处理剩余部分。

- 使用 `memo` 数组记录已计算过的位置，避免重复计算。
- 时间复杂度与 DP 相当，但常数较大，且递归深度可能引起栈溢出（对长字符串不友好）。

______________________________________________________________________

### 💡 方法三：BFS（广度优先搜索）

将问题视为图搜索：

- 节点：字符串的起始位置（0 到 n）
- 边：若从位置 `i` 开始存在一个字典单词 `w`，则可跳转到 `i + len(w)`

用队列维护当前可到达的位置，最终判断是否能到达 `n`。

> ⚠️ 实现较复杂，效率不如 DP。

______________________________________________________________________

## 代码实现

<div class="code-tabs">

```java:Java
import java.util.*;

public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        Set<String> wordSet = new HashSet<>(wordDict);
        int n = s.length();
        boolean[] dp = new boolean[n + 1];
        dp[0] = true; // 空字符串可被拆分

        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && wordSet.contains(s.substring(j, i))) {
                    dp[i] = true;
                    break; // 找到一个即可
                }
            }
        }

        return dp[n];
    }
}
```

```go:Go
func wordBreak(s string, wordDict []string) bool {
    wordSet := make(map[string]bool)
    for _, word := range wordDict {
        wordSet[word] = true
    }

    n := len(s)
    dp := make([]bool, n+1)
    dp[0] = true

    for i := 1; i <= n; i++ {
        for j := 0; j < i; j++ {
            if dp[j] && wordSet[s[j:i]] {
                dp[i] = true
                break
            }
        }
    }

    return dp[n]
}
```

</div>

______________________________________________________________________

## 示例演示

以 `s = "leetcode"`, `wordDict = ["leet", "code"]` 为例：

| i | j | s[j:i] | dp[j] | in dict? | dp[i] |
|---|---|--------|-------|----------|-------|
| 1 | 0 | "l" | T | ❌ | F |
| 2 | 0 | "le" | T | ❌ | F |
| 3 | 0 | "lee" | T | ❌ | F |
| 4 | 0 | "leet" | T | ✅ | ✅ → dp[4]=T |
| 5 | 0 | "leetc"| T | ❌ | |
| | 4 | "c" | T | ❌ | F |
| ... | ... | ... | ... | ... | ... |
| 8 | 4 | "code" | T | ✅ | ✅ → dp[8]=T |

最终 `dp[8] = true`，返回 `true`。

______________________________________________________________________

## 答案有效性证明

- **正确性**：\
  动态规划覆盖了所有可能的分割点。若存在一种合法分割方式，必存在某个 `j` 使得 `s[0:j]` 可分割且 `s[j:i]` 在字典中，DP 会捕获该情况。

- **完备性**：\
  由于我们遍历了所有 `j < i`，不会遗漏任何可能的前缀组合。

- **边界处理**：\
  `dp[0] = true` 是关键基础情形，确保第一个单词能被正确识别。

______________________________________________________________________

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 动态规划 | $O(n^2)$ | $O(n + m)$ | `n = len(s)`, `m = sum(len(word))`（用于 set） |
| 记忆化 DFS | $O(n^2)$ | $O(n)$ | 最坏情况下每个子串都被检查一次 |
| BFS | $O(n^2)$ | $O(n)$ | 类似 DP，但常数更大 |

> 💡 实际中 DP 最优，因其无递归开销、缓存友好。

______________________________________________________________________

## 问题总结

✅ **核心思想**：将字符串拆分问题转化为**子问题重叠**的动态规划模型。\
✅ **关键技巧**：使用哈希集合加速字典查找。\
✅ **适用场景**：字符串分割、词典匹配、句子还原等 NLP 基础问题。\
📌 **延伸思考**：若要求输出所有可能的拆分方案（如 LeetCode 140），则需用回溯法。
