# 问题简介

[LeetCode 142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定一个链表的头节点 `head`，返回链表开始入环的第一个节点。 如果链表无环，则返回 `null`。

为了表示给定链表中的环，使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 `pos` 是 -1，则在该链表中没有环。注意，`pos` 仅仅是用于标识环的情况，并不会作为参数传递到函数中。

**说明**：不允许修改给定的链表。

______________________________________________________________________

# 示例说明

✅ **示例 1**：

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

✅ **示例 2**：

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

✅ **示例 3**：

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```

______________________________________________________________________

# 解题思路

## ✅ 方法一：Floyd 判圈算法（快慢指针）

这是最经典、最优的解法，分为两个阶段：

### 📌 第一阶段：检测是否存在环

- 使用快慢指针（slow 和 fast）
- slow 每次走 1 步，fast 每次走 2 步
- 如果存在环，fast 最终会追上 slow；如果不存在环，fast 会到达 null

### 📌 第二阶段：找到环的入口

- 当快慢指针相遇后，将其中一个指针重置到头节点
- 两个指针都以相同速度（每次 1 步）前进
- 它们再次相遇的点就是环的入口

### 💡 数学证明（关键！）

假设：

- 链表头到环入口的距离为 `a`
- 环入口到相遇点的距离为 `b`
- 相遇点到环入口的距离为 `c`（即环的剩余部分）

当快慢指针相遇时：

- slow 走过的距离：`a + b`
- fast 走过的距离：`a + b + n(b + c)`，其中 n 是 fast 在环内绕的圈数

由于 fast 速度是 slow 的 2 倍：

```
2(a + b) = a + b + n(b + c)
=> a + b = n(b + c)
=> a = (n-1)(b + c) + c
```

这意味着：从头节点到环入口的距离 `a` 等于从相遇点继续走 `(n-1)` 圈再走 `c` 的距离。
因此，当一个指针从头开始，另一个从相遇点开始，它们会在环入口相遇。

## ❌ 方法二：哈希表（空间换时间）

- 遍历链表，将每个访问过的节点存入哈希表
- 如果遇到已经存在的节点，说明找到了环的入口
- 时间复杂度 O(n)，空间复杂度 O(n)

虽然简单直观，但不符合题目"不修改链表"的隐含要求（虽然没直接修改，但用了额外空间），且空间效率不如方法一。

______________________________________________________________________

# 代码实现


```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null || head.next == null) {
            return null;
        }
        
        // 第一阶段：检测环
        ListNode slow = head;
        ListNode fast = head;
        
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            
            if (slow == fast) {
                // 第二阶段：找环入口
                ListNode ptr = head;
                while (ptr != slow) {
                    ptr = ptr.next;
                    slow = slow.next;
                }
                return ptr;
            }
        }
        
        return null; // 无环
    }
}
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return nil
    }
    
    // 第一阶段：检测环
    slow := head
    fast := head
    
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        
        if slow == fast {
            // 第二阶段：找环入口
            ptr := head
            for ptr != slow {
                ptr = ptr.Next
                slow = slow.Next
            }
            return ptr
        }
    }
    
    return nil // 无环
}
```
______________________________________________________________________

# 示例演示

让我们用示例 1 来演示算法过程：

```
链表: 3 -> 2 -> 0 -> -4
           ↑         ↓
           ←---------←
```

**第一阶段（检测环）**：

- slow: 3 → 2 → 0 → -4 → 2 → 0
- fast: 3 → 0 → 2 → -4 → 0 → 2
- 在节点 0 处相遇

**第二阶段（找入口）**：

- ptr 从 3 开始，slow 从 0 开始
- ptr: 3 → 2
- slow: 0 → -4 → 2
- 在节点 2 处相遇，这就是环的入口！

______________________________________________________________________

# 答案有效性证明

✅ **正确性证明**：

1. **存在性**：如果链表有环，快指针必然能追上慢指针（因为相对速度为1）
1. **唯一性**：根据数学推导 `a = (n-1)(b + c) + c`，从头节点和相遇点同时出发的两个指针必然在环入口相遇
1. **边界情况**：
   - 空链表或单节点：直接返回 null
   - 整个链表就是一个环：入口就是头节点

✅ **算法终止性**：

- 无环情况下，fast 指针会在 O(n) 步内到达 null
- 有环情况下，快慢指针必在 O(n) 步内相遇

______________________________________________________________________

# 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 是否修改原链表 |
|------|------------|------------|----------------|
| Floyd 判圈算法 | O(n) | O(1) | ❌ 否 |
| 哈希表 | O(n) | O(n) | ❌ 否 |

**详细分析**：

- **时间复杂度 O(n)**：每个节点最多被访问常数次
- **空间复杂度 O(1)**：只使用了固定数量的指针变量

______________________________________________________________________

# 问题总结

📌 **核心要点**：

1. **Floyd 判圈算法**是解决此类问题的标准方法
1. **数学推导**是理解为什么重置指针后能找到入口的关键
1. **两阶段策略**：先检测环的存在，再定位入口

💡 **面试技巧**：

- 务必能够清晰地解释数学证明部分
- 可以先提出哈希表解法，再优化到快慢指针
- 注意处理边界情况（空链表、单节点等）

✅ **适用场景**：

- 链表环检测问题
- 类似的双指针问题（如寻找重复数）
- 需要 O(1) 空间复杂度的环形结构问题
