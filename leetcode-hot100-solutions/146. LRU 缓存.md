# LRU 缓存

## 问题简介

[LeetCode 146. LRU 缓存](https://leetcode.cn/problems/lru-cache?envType=problem-list-v2&envId=2cktkvj)

请你设计并实现一个满足 [LRU (最近最少使用)](https://baike.baidu.com/item/LRU) 缓存约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1`。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value`；如果不存在，则向缓存中插入该组 `key-value`。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

## 示例说明

**示例 1：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

## 解题思路

### ✅ 核心思想

LRU（Least Recently Used）缓存的核心要求是：

1. **快速查找**：能在 O(1) 时间内判断 key 是否存在并获取 value
1. **快速更新使用顺序**：每次访问（get/put）都要将该元素标记为"最近使用"
1. **快速淘汰**：当容量满时，能快速找到并删除"最久未使用"的元素

### ✅ 解法一：哈希表 + 双向链表（推荐）

这是最经典且高效的解法：

1. **数据结构选择**：

   - **哈希表（HashMap）**：提供 O(1) 的 key 查找能力
   - **双向链表（Doubly Linked List）**：维护元素的使用顺序，头部为最近使用，尾部为最久未使用

1. **关键操作**：

   - **get(key)**：如果存在，返回值并将对应节点移到链表头部
   - **put(key, value)**：
     - 如果 key 已存在：更新值并将节点移到头部
     - 如果 key 不存在：
       - 如果容量未满：创建新节点并添加到头部
       - 如果容量已满：删除尾部节点（最久未使用），然后创建新节点添加到头部

1. **辅助方法**：

   - `addToHead(node)`：将节点添加到链表头部
   - `removeNode(node)`：从链表中删除指定节点
   - `moveToHead(node)`：将节点移动到链表头部（先删除再添加到头部）
   - `removeTail()`：删除并返回链表尾部节点

### ❌ 解法二：仅使用哈希表（不推荐）

虽然可以用哈希表存储数据，但无法高效维护使用顺序，需要额外的时间复杂度来跟踪和更新顺序。

### ❌ 解法三：使用数组或列表（不推荐）

虽然可以维护顺序，但查找、删除和移动操作的时间复杂度较高，无法满足 O(1) 的要求。

### 💡 为什么双向链表？

- **单向链表**：删除节点时需要知道前驱节点，否则无法更新前驱的 next 指针
- **双向链表**：每个节点都有 prev 和 next 指针，可以 O(1) 时间删除任意节点

## 代码实现

```java:Java
class LRUCache {
    class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        
        public DLinkedNode() {}
        
        public DLinkedNode(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private Map<Integer, DLinkedNode> cache = new HashMap<>();
    private int size;
    private int capacity;
    private DLinkedNode head, tail;
    
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }
    
    public void put(int key, int value) {
        DLinkedNode node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            DLinkedNode newNode = new DLinkedNode(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                DLinkedNode tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        } else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }
    
    private void addToHead(DLinkedNode node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    private void removeNode(DLinkedNode node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void moveToHead(DLinkedNode node) {
        removeNode(node);
        addToHead(node);
    }
    
    private DLinkedNode removeTail() {
        DLinkedNode res = tail.prev;
        removeNode(res);
        return res;
    }
}
```

```go:Go
type LRUCache struct {
    capacity int
    cache map[int]*DLinkedNode
    head, tail *DLinkedNode
}

type DLinkedNode struct {
    key, value int
    prev, next *DLinkedNode
}

func Constructor(capacity int) LRUCache {
    l := LRUCache{
        capacity: capacity,
        cache: make(map[int]*DLinkedNode),
        head: &DLinkedNode{},
        tail: &DLinkedNode{},
    }
    l.head.next = l.tail
    l.tail.prev = l.head
    return l
}

func (this *LRUCache) Get(key int) int {
    if node, ok := this.cache[key]; ok {
        this.moveToHead(node)
        return node.value
    }
    return -1
}

func (this *LRUCache) Put(key int, value int) {
    if node, ok := this.cache[key]; ok {
        node.value = value
        this.moveToHead(node)
    } else {
        newNode := &DLinkedNode{key: key, value: value}
        this.cache[key] = newNode
        this.addToHead(newNode)
        if len(this.cache) > this.capacity {
            tail := this.removeTail()
            delete(this.cache, tail.key)
        }
    }
}

func (this *LRUCache) addToHead(node *DLinkedNode) {
    node.prev = this.head
    node.next = this.head.next
    this.head.next.prev = node
    this.head.next = node
}

func (this *LRUCache) removeNode(node *DLinkedNode) {
    node.prev.next = node.next
    node.next.prev = node.prev
}

func (this *LRUCache) moveToHead(node *DLinkedNode) {
    this.removeNode(node)
    this.addToHead(node)
}

func (this *LRUCache) removeTail() *DLinkedNode {
    node := this.tail.prev
    this.removeNode(node)
    return node
}
```


## 示例演示

让我们跟踪示例 1 的执行过程：

| 操作 | 缓存状态（头部←→尾部） | 说明 |
|------|----------------------|------|
| `LRUCache(2)` | 空 | 初始化容量为2的缓存 |
| `put(1,1)` | `[1=1]` | 插入键值对 |
| `put(2,2)` | `[2=2] ↔ [1=1]` | 插入键值对，2成为最近使用 |
| `get(1)` | `[1=1] ↔ [2=2]` | 访问1，1成为最近使用，返回1 |
| `put(3,3)` | `[3=3] ↔ [1=1]` | 插入3，容量满，淘汰最久未使用的2 |
| `get(2)` | `[3=3] ↔ [1=1]` | 2不存在，返回-1 |
| `put(4,4)` | `[4=4] ↔ [3=3]` | 插入4，容量满，淘汰最久未使用的1 |
| `get(1)` | `[4=4] ↔ [3=3]` | 1不存在，返回-1 |
| `get(3)` | `[3=3] ↔ [4=4]` | 访问3，3成为最近使用，返回3 |
| `get(4)` | `[4=4] ↔ [3=3]` | 访问4，4成为最近使用，返回4 |

## 答案有效性证明

### ✅ 正确性证明

1. **查找正确性**：通过哈希表确保能正确找到存在的 key，不存在的 key 返回 -1
2. **更新正确性**：
   - 已存在的 key：更新值并移动到头部（标记为最近使用）
   - 不存在的 key：创建新节点并添加到头部
3. **淘汰正确性**：当容量超限时，总是删除尾部节点（最久未使用的元素）
4. **顺序维护正确性**：每次访问都移动到头部，确保链表按使用时间排序

### ✅ 边界情况处理

- **容量为1**：每次 put 都会淘汰之前的元素
- **重复 put 相同 key**：正确更新值并重置使用时间
- **连续 get 相同 key**：每次都正确返回值并重置使用时间

## 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| **初始化** | O(1) | O(1) |
| **get** | O(1) | O(1) |
| **put** | O(1) | O(1) |
| **总体空间** | - | O(capacity) |

**详细分析：**
- **时间复杂度**：所有操作都是 O(1)，因为哈希表查找和双向链表的插入/删除都是常数时间
- **空间复杂度**：O(capacity)，哈希表和双向链表最多存储 capacity 个元素

## 问题总结

### 📌 关键要点

1. **LRU 核心**：最近使用的在前，最久未使用的在后
2. **数据结构组合**：哈希表（快速查找）+ 双向链表（维护顺序）
3. **边界处理**：容量限制、重复操作、空缓存等

### 💡 面试技巧

- **理解原理**：不仅要会写代码，还要理解为什么选择这种数据结构组合
- **画图辅助**：在面试时可以画出双向链表的结构来帮助解释
- **考虑扩展**：可以讨论如何支持并发访问、如何持久化等扩展问题

### ✅ 实际应用

LRU 缓存广泛应用于：
- 数据库查询缓存
- Web 服务器页面缓存  
- 操作系统内存管理
- 浏览器缓存机制

这种设计模式体现了**空间换时间**的思想，在有限的内存空间内最大化缓存命中率。
