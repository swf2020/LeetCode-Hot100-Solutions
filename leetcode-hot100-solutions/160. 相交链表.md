# 160. 相交链表

[LeetCode 题目链接](https://leetcode.cn/problems/intersection-of-two-linked-lists?envType=problem-list-v2&envId=2cktkvj)

## 📌 问题简介

给你两个单链表的头节点 `headA` 和 `headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null`。

图示两个链表在节点 `c1` 开始相交：

```
A:          a1 → a2
                   ↘
                     c1 → c2 → c3
                   ↗            
B:     b1 → b2 → b3
```

题目数据保证整个链式结构中不存在环。

注意：函数返回结果后，链表必须保持其原始结构。

### 示例说明

**示例 1：**

输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3\
输出：Intersected at '8'\
解释：相交节点的值为 8（注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。

**示例 2：**

输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\
输出：Intersected at '2'\
解释：相交节点的值为 2。从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。

**示例 3：**

输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\
输出：null\
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。这两个链表不相交，因此返回 null。

## 💡 解题思路

### 方法一：双指针法（推荐）

这是最优雅的解法，核心思想是让两个指针分别遍历两个链表，当一个指针到达链表末尾时，将其重定向到另一个链表的头部。这样两个指针最终会相遇在相交节点，或者同时到达 null（无相交）。

**步骤：**

1. 创建两个指针 `pA` 和 `pB`，分别指向 `headA` 和 `headB`
1. 当 `pA` 不等于 `pB` 时，继续循环
1. 如果 `pA` 到达末尾（null），则将其指向 `headB`；否则移动到下一个节点
1. 如果 `pB` 到达末尾（null），则将其指向 `headA`；否则移动到下一个节点
1. 当两个指针相遇时，返回该节点（可能是相交节点，也可能是 null）

**为什么有效？**

- 如果两个链表相交，设链表 A 独有部分长度为 `a`，链表 B 独有部分长度为 `b`，公共部分长度为 `c`
- `pA` 走过的路径：`a + c + b`
- `pB` 走过的路径：`b + c + a`
- 两者路径长度相同，会在相交点相遇

### 方法二：哈希集合

**步骤：**

1. 遍历链表 A，将所有节点存入哈希集合
1. 遍历链表 B，检查每个节点是否在哈希集合中
1. 第一个在集合中的节点就是相交节点
1. 如果遍历完都没有找到，返回 null

### 方法三：计算长度差

**步骤：**

1. 分别计算两个链表的长度
1. 让较长的链表先走长度差的步数
1. 然后两个链表同时开始遍历，第一个相同的节点就是相交节点

## 💻 代码实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    // 方法一：双指针法
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        
        ListNode pA = headA;
        ListNode pB = headB;
        
        while (pA != pB) {
            pA = (pA == null) ? headB : pA.next;
            pB = (pB == null) ? headA : pB.next;
        }
        
        return pA;
    }
    
    // 方法二：哈希集合
    public ListNode getIntersectionNodeHashSet(ListNode headA, ListNode headB) {
        Set<ListNode> visited = new HashSet<>();
        ListNode temp = headA;
        
        while (temp != null) {
            visited.add(temp);
            temp = temp.next;
        }
        
        temp = headB;
        while (temp != null) {
            if (visited.contains(temp)) {
                return temp;
            }
            temp = temp.next;
        }
        
        return null;
    }
    
    // 方法三：计算长度差
    public ListNode getIntersectionNodeLengthDiff(ListNode headA, ListNode headB) {
        int lenA = getLength(headA);
        int lenB = getLength(headB);
        
        // 让较长的链表先走
        while (lenA > lenB) {
            headA = headA.next;
            lenA--;
        }
        while (lenB > lenA) {
            headB = headB.next;
            lenB--;
        }
        
        // 同时遍历，找相交点
        while (headA != null && headB != null) {
            if (headA == headB) {
                return headA;
            }
            headA = headA.next;
            headB = headB.next;
        }
        
        return null;
    }
    
    private int getLength(ListNode head) {
        int length = 0;
        while (head != null) {
            length++;
            head = head.next;
        }
        return length;
    }
}
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
 
// 方法一：双指针法
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }
    
    pA, pB := headA, headB
    
    for pA != pB {
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }
        
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    
    return pA
}

// 方法二：哈希集合
func getIntersectionNodeHashSet(headA, headB *ListNode) *ListNode {
    visited := make(map[*ListNode]bool)
    temp := headA
    
    for temp != nil {
        visited[temp] = true
        temp = temp.Next
    }
    
    temp = headB
    for temp != nil {
        if visited[temp] {
            return temp
        }
        temp = temp.Next
    }
    
    return nil
}

// 方法三：计算长度差
func getIntersectionNodeLengthDiff(headA, headB *ListNode) *ListNode {
    lenA := getLength(headA)
    lenB := getLength(headB)
    
    // 让较长的链表先走
    for lenA > lenB {
        headA = headA.Next
        lenA--
    }
    for lenB > lenA {
        headB = headB.Next
        lenB--
    }
    
    // 同时遍历，找相交点
    for headA != nil && headB != nil {
        if headA == headB {
            return headA
        }
        headA = headA.Next
        headB = headB.Next
    }
    
    return nil
}

func getLength(head *ListNode) int {
    length := 0
    for head != nil {
        length++
        head = head.Next
    }
    return length
}
```

## 🎯 示例演示

让我们用示例 1 来演示双指针法的执行过程：

```
初始状态：
A: [4,1,8,4,5]
B: [5,6,1,8,4,5]

pA = 4, pB = 5
pA = 1, pB = 6  
pA = 8, pB = 1
pA = 4, pB = 8
pA = 5, pB = 4
pA = null, pB = 5
pA = 5 (重定向到B头), pB = null
pA = 6, pB = 4 (重定向到A头)
pA = 1, pB = 1
pA = 8, pB = 8 ← 相遇！返回节点8
```

## ✅ 答案有效性证明

**双指针法正确性证明：**

设链表 A 的独有部分长度为 `a`，链表 B 的独有部分长度为 `b`，公共部分长度为 `c`。

- **情况1：有相交节点**

  - 指针 pA 的路径：`a + c + b`
  - 指针 pB 的路径：`b + c + a`
  - 由于 `a + c + b = b + c + a`，两个指针会在相交节点相遇

- **情况2：无相交节点**

  - 此时 `c = 0`
  - 指针 pA 的路径：`a + b`
  - 指针 pB 的路径：`b + a`
  - 两个指针都会在遍历完两个链表后同时到达 null，此时 `pA == pB == null`，返回 null

因此，该算法在所有情况下都能正确工作。

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|--------|
| **双指针法** | O(m + n) | O(1) | ✅ 最优解，空间效率高 |
| **哈希集合** | O(m + n) | O(m) | ❌ 需要额外空间存储 |
| **长度差法** | O(m + n) | O(1) | ✅ 空间效率高，但需要两次遍历 |

其中 m 和 n 分别是两个链表的长度。

- **双指针法**：只需要一次遍历，常数空间，代码简洁
- **哈希集合**：直观易懂，但空间开销大
- **长度差法**：需要先计算长度，再调整起始位置，逻辑稍复杂

## 🔚 问题总结

❌ **常见错误：**

- 直接比较节点值而不是节点引用（题目要求比较的是节点对象本身）
- 忘记处理 null 情况
- 在双指针法中错误地在每次循环都重置指针

✅ **关键要点：**

- 相交链表的相交点是指内存地址相同的节点，不是值相同
- 双指针法的核心思想是通过路径长度相等来保证相遇
- 所有方法的时间复杂度都是 O(m + n)，但空间复杂度不同

💡 **面试建议：**

- 首先提出哈希集合的直观解法
- 然后优化到双指针法，展示对算法优化的理解
- 能够清晰解释双指针法的数学原理
- 注意边界条件的处理（空链表、无相交等情况）
