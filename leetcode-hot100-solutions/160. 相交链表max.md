## 问题简介

[160. 相交链表 - 力扣](https://leetcode.cn/problems/intersection-of-two-linked-lists?envType=problem-list-v2&envId=2cktkvj)

给你两个单链表的头节点 `headA` 和 `headB`，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 `null`。

图示两个链表在节点 `c1` 开始相交：

- 题目数据保证整个链表结构中不存在环。
- 注意，函数返回结果后，链表必须保持其原始结构。

## 示例说明

**示例 1：**

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
```

**示例 2：**

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
```

**示例 3：**

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
```

## 解题思路

### 方法一：双指针法（推荐）

**💡 核心思想：** 让两个指针分别遍历两个链表，当到达末尾时转向另一个链表的头部，这样两个指针最终会同时到达相交点或同时到达末尾。

**步骤详解：**

1. 设指针 pA 指向链表 A 的头节点，pB 指向链表 B 的头节点
1. 当 pA 到达链表 A 的末尾时，将其指向链表 B 的头节点
1. 当 pB 到达链表 B 的末尾时，将其指向链表 A 的头节点
1. 如果存在相交节点，两个指针会在相交节点相遇
1. 如果不存在相交节点，两个指针都会为 null

**数学原理：**

- 假设链表 A 长度为 m，链表 B 长度为 n，公共部分长度为 c
- 链表 A 独有部分长度为 m-c，链表 B 独有部分长度为 n-c
- 路径：(m-c) + (n-c) + c = (n-c) + (m-c) + c
- 所以两个指针走过的距离相等

### 方法二：哈希表法

**步骤：**

1. 将链表 A 的所有节点存入哈希表
1. 遍历链表 B，检查每个节点是否存在于哈希表中
1. 第一个存在的节点即为相交节点

## 代码实现

```java
// Java 实现
public class Solution {
    // 方法一：双指针法
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        if (headA == null || headB == null) {
            return null;
        }
        
        ListNode pA = headA, pB = headB;
        
        // 当两个指针相遇时停止循环
        while (pA != pB) {
            pA = pA == null ? headB : pA.next;
            pB = pB == null ? headA : pB.next;
        }
        
        return pA; // 返回相交节点或 null
    }
    
    // 方法二：哈希表法
    public ListNode getIntersectionNodeHash(ListNode headA, ListNode headB) {
        Set<ListNode> visited = new HashSet<>();
        
        ListNode temp = headA;
        while (temp != null) {
            visited.add(temp);
            temp = temp.next;
        }
        
        temp = headB;
        while (temp != null) {
            if (visited.contains(temp)) {
                return temp;
            }
            temp = temp.next;
        }
        
        return null;
    }
}
```

```go
// Go 实现
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }
    
    pA, pB := headA, headB
    
    for pA != pB {
        if pA == nil {
            pA = headB
        } else {
            pA = pA.Next
        }
        
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    
    return pA
}

// 方法二：哈希表法
func getIntersectionNodeHash(headA, headB *ListNode) *ListNode {
    visited := make(map[*ListNode]bool)
    
    temp := headA
    for temp != nil {
        visited[temp] = true
        temp = temp.Next
    }
    
    temp = headB
    for temp != nil {
        if visited[temp] {
            return temp
        }
        temp = temp.Next
    }
    
    return nil
}
```

## 示例演示

假设链表 A: 4→1→8→4→5，链表 B: 5→6→1→8→4→5，相交于节点 8

```
A: 4 → 1 → 8 → 4 → 5
              ↘
B:     5 → 6 → 1 → 8 → 4 → 5
```

**双指针执行过程：**

| 步数 | pA路径 | pB路径 | 说明 |
|------|--------|--------|------|
| 1-5 | 4→1→8→4→5 | 5→6→1→8→4 | pA到末尾，转向headB |
| 6 | null → headB | 5 | pA = headB |
| 7-10 | 5→6→1→8 | 5→6→1→8 | pA和pB在节点8相遇 |

## 答案有效性证明

**✅ 正确性证明：**

1. **存在相交节点的情况：**

   - 设链表A独有部分长度为a，链表B独有部分长度为b，公共部分长度为c
   - pA走过的路径：a + c + b（A独有+公共+转到B独有）
   - pB走过的路径：b + c + a（B独有+公共+转到A独有）
   - 两者路径长度相等，且都在相交点相遇

1. **不存在相交节点的情况：**

   - pA和pB都会走过 a + c + b + c = b + c + a + c 的距离
   - 最终都到达null，返回null

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|--------|
| 双指针法 | O(m+n) | O(1) | ✅ 空间最优，推荐使用 |
| 哈希表法 | O(m+n) | O(m) | ❌ 需要额外空间 |

**详细分析：**

- **时间复杂度：** O(m+n)，其中m和n分别是两个链表的长度
- **空间复杂度：**
  - 双指针法：O(1)，只使用了常数个指针变量
  - 哈希表法：O(m)，需要存储链表A的所有节点

## 问题总结

**📌 关键要点：**

1. **核心思想：** 双指针法利用"绕路"的思想，让两个指针走相同的总距离
1. **边界处理：** 需要考虑空链表的情况
1. **终止条件：** 两个指针相遇时停止，可能是相交节点或null
1. **空间优化：** 双指针法是空间最优解，无需额外存储空间

**💡 技巧总结：**

- 这类链表问题常考虑双指针技巧
- 当需要处理两个链表时，可以考虑让指针"接力"遍历
- 对于相交问题，关键是找到让两个指针"同步"的方法

**✅ 推荐方案：** 双指针法，时间复杂度O(m+n)，空间复杂度O(1)，是最优解。
