# 208. 实现 Trie (前缀树)

[LeetCode 题目链接](https://leetcode.cn/problems/implement-trie-prefix-tree?envType=problem-list-v2&envId=2cktkvj)

## ❓ 问题简介

### 题目描述

Trie（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 。

## 🧪 示例说明

```text
输入
["Trie", "insert", "search", "search", "startsWith", "insert", "search"]
[[], ["apple"], ["apple"], ["app"], ["app"], ["app"], ["app"]]
输出
[null, null, true, false, true, null, true]

解释
Trie trie = new Trie();
trie.insert("apple");
trie.search("apple");   // 返回 True
trie.search("app");     // 返回 False
trie.startsWith("app"); // 返回 True
trie.insert("app");
trie.search("app");     // 返回 True
```

📌 **关键点理解**：

- `search` 要求完整匹配一个已插入的单词；
- `startsWith` 只要存在以该前缀开头的单词即可（不要求是完整单词）。

______________________________________________________________________

## 💡 解题思路

### 基本思想

Trie 树的核心思想是**用树的路径表示字符串的字符序列**。每个节点代表一个字符，从根到某个节点的路径构成一个字符串前缀。

#### ✅ 步骤分解：

1. **设计 TrieNode 节点结构**：

   - 包含一个大小为 26 的子节点数组（假设只包含小写字母 `'a'-'z'`）；
   - 或使用哈希表（更通用，支持任意字符）；
   - 一个布尔标志 `isEnd` 表示当前路径是否构成一个完整单词。

1. **插入操作 `insert(word)`**：

   - 从根节点开始；
   - 对每个字符 `c`，检查当前节点是否有对应子节点；
     - 若无，则新建；
   - 移动到子节点；
   - 最后将末尾节点的 `isEnd` 设为 `true`。

1. **搜索操作 `search(word)`**：

   - 从根开始遍历每个字符；
   - 若某字符无对应子节点，返回 `false`；
   - 遍历完所有字符后，检查最后一个节点的 `isEnd` 是否为 `true`。

1. **前缀匹配 `startsWith(prefix)`**：

   - 与 `search` 类似，但**不需要检查 `isEnd`**；
   - 只要能完整遍历完 `prefix` 的所有字符，就返回 `true`。

______________________________________________________________________

### 🔁 其他解法对比

| 方法 | 数据结构 | 优点 | 缺点 |
|------|--------|------|------|
| **数组法** | `TrieNode[26]` | 访问快 O(1)，内存连续 | 仅限固定字符集（如小写字母），空间浪费（稀疏时） |
| **哈希表法** | `Map<Character, TrieNode>` | 通用性强，节省空间 | 哈希开销，常数因子略大 |

> 💡 本题限定小写字母，**数组法更优**；若扩展至 Unicode 或大小写混合，应选哈希表。

______________________________________________________________________

## 💻 代码实现

```java
class Trie {
    private static class TrieNode {
        TrieNode[] children;
        boolean isEnd;

        public TrieNode() {
            children = new TrieNode[26];
            isEnd = false;
        }
    }

    private TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode node = root;
        for (char c : word.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                node.children[idx] = new TrieNode();
            }
            node = node.children[idx];
        }
        node.isEnd = true;
    }

    public boolean search(String word) {
        TrieNode node = findPrefix(word);
        return node != null && node.isEnd;
    }

    public boolean startsWith(String prefix) {
        return findPrefix(prefix) != null;
    }

    private TrieNode findPrefix(String prefix) {
        TrieNode node = root;
        for (char c : prefix.toCharArray()) {
            int idx = c - 'a';
            if (node.children[idx] == null) {
                return null;
            }
            node = node.children[idx];
        }
        return node;
    }
}
```

```go
type TrieNode struct {
    children [26]*TrieNode
    isEnd    bool
}

type Trie struct {
    root *TrieNode
}

func Constructor() Trie {
    return Trie{root: &TrieNode{}}
}

func (t *Trie) Insert(word string) {
    node := t.root
    for _, ch := range word {
        idx := ch - 'a'
        if node.children[idx] == nil {
            node.children[idx] = &TrieNode{}
        }
        node = node.children[idx]
    }
    node.isEnd = true
}

func (t *Trie) Search(word string) bool {
    node := t.findPrefix(word)
    return node != nil && node.isEnd
}

func (t *Trie) StartsWith(prefix string) bool {
    return t.findPrefix(prefix) != nil
}

func (t *Trie) findPrefix(prefix string) *TrieNode {
    node := t.root
    for _, ch := range prefix {
        idx := ch - 'a'
        if node.children[idx] == nil {
            return nil
        }
        node = node.children[idx]
    }
    return node
}
```

______________________________________________________________________

## 🎯 示例演示

以插入 `"apple"` 和 `"app"` 为例，Trie 结构如下：

```
        root
         |
         a
         |
         p
         |
         p
        / \
       l   (isEnd=true)
       |
       e
       |
    (isEnd=true)
```

- `search("app")` → 到第二个 `p` 节点，`isEnd=true` → ✅ `true`
- `search("ap")` → 到第一个 `p` 节点，`isEnd=false` → ❌ `false`
- `startsWith("ap")` → 能走到第一个 `p` → ✅ `true`

______________________________________________________________________

## ✅ 答案有效性证明

1. **正确性**：

   - 插入：每个字符路径被创建，末尾标记 `isEnd`；
   - 搜索：只有完整路径 + `isEnd=true` 才返回 `true`；
   - 前缀：只要路径存在即返回 `true`，符合定义。

1. **边界测试**：

   - 空字符串：可处理（若允许插入空串，则根节点 `isEnd=true`）；
   - 重复插入：多次插入同一单词，`isEnd` 保持 `true`，无副作用；
   - 不存在的前缀：提前返回 `null`/`nil`，避免越界。

______________________________________________________________________

## ⏱️ 复杂度分析

| 操作 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| `insert` | O(m) | O(m) |
| `search` | O(m) | O(1) |
| `startsWith` | O(m) | O(1) |

其中 `m` 为输入字符串的长度。

- **时间**：每个操作最多遍历字符串长度，每步 O(1)；
- **空间**：
  - 单次插入最坏新增 `m` 个节点；
  - 总体空间取决于所有插入单词的**公共前缀共享程度**；
  - 最坏情况（无公共前缀）：O(ALPHABET_SIZE × N × M)，N 为单词数，M 为平均长度。

> 💡 Trie 的优势在于**前缀共享**，大量公共前缀时空间远优于哈希表。

______________________________________________________________________

## 📌 问题总结

- **Trie 是处理字符串前缀问题的利器**，特别适合自动补全、拼写检查、IP 路由等场景；
- **核心在于节点设计与路径遍历**，注意区分 `search`（需完整词）与 `startsWith`（只需前缀）；
- **数组 vs 哈希表**：根据字符集选择，小写字母用数组更高效；
- **空间换时间**：Trie 通过共享前缀减少重复存储，提升查询效率；
- **扩展思考**：可增加 `delete`、`getWordsWithPrefix` 等功能，或支持通配符（如 LeetCode 211）。

✅ 掌握 Trie 的实现，是解决字符串高级问题的重要基础！
