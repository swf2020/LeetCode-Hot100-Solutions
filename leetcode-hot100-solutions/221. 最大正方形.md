### 问题简介

🔗 [LeetCode 221. 最大正方形](https://leetcode.cn/problems/maximal-square?envType=problem-list-v2&envId=2cktkvj)

#### 题目描述

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

______________________________________________________________________

### 示例说明

**示例 1：**

```
输入：
matrix = [
  ["1","0","1","0","0"],
  ["1","0","1","1","1"],
  ["1","1","1","1","1"],
  ["1","0","0","1","0"]
]
输出：4
```

✅ 解释：右下角存在一个 2×2 的全为 `'1'` 的正方形，面积为 4。

**示例 2：**

```
输入：
matrix = [["0"]]
输出：0
```

**示例 3：**

```
输入：
matrix = [["1"]]
输出：1
```

______________________________________________________________________

### 解题思路

📌 **核心观察**：\
要判断以 `(i, j)` 为右下角的最大正方形边长，需要知道其左、上、左上三个方向能构成的最大正方形边长。这天然适合使用**动态规划（DP）**。

______________________________________________________________________

#### ✅ 方法一：动态规划（推荐）

**状态定义**：\
设 `dp[i][j]` 表示以 `(i, j)` 为右下角的最大正方形的**边长**。

**状态转移方程**：

- 如果 `matrix[i][j] == '0'`，则 `dp[i][j] = 0`
- 如果 `matrix[i][j] == '1'`，则\
  `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`

**边界处理**：\
第 0 行和第 0 列可直接初始化为 `matrix[i][j] - '0'`。

**答案**：\
遍历过程中记录 `maxSide = max(maxSide, dp[i][j])`，最终返回 `maxSide * maxSide`。

______________________________________________________________________

#### ❌ 方法二：暴力枚举（不推荐，仅用于理解）

- 枚举每个位置作为正方形左上角
- 尝试扩展边长 1, 2, 3... 直到越界或遇到 `'0'`
- 时间复杂度高（O(mn·min(m,n))），会超时

______________________________________________________________________

#### 💡 方法三：优化空间的 DP（滚动数组）

由于 `dp[i][j]` 只依赖于当前行和上一行，可用两个一维数组（或一个）压缩空间。

但为了清晰，我们先展示标准二维 DP，再在 Go/Java 中提供空间优化版本（可选）。

______________________________________________________________________

### 代码实现

```java
// Java - 动态规划（标准二维DP）
class Solution {
    public int maximalSquare(char[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0;
        int m = matrix.length, n = matrix[0].length;
        int[][] dp = new int[m][n];
        int maxSide = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == '1') {
                    if (i == 0 || j == 0) {
                        dp[i][j] = 1;
                    } else {
                        dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                    }
                    maxSide = Math.max(maxSide, dp[i][j]);
                }
            }
        }
        return maxSide * maxSide;
    }
}
```

```go
// Go - 动态规划（空间优化版：仅用一行）
func maximalSquare(matrix [][]byte) int {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return 0
    }
    m, n := len(matrix), len(matrix[0])
    dp := make([]int, n+1) // 多一位避免边界判断
    maxSide := 0
    prev := 0 // 保存 dp[i-1][j-1]

    for i := 0; i < m; i++ {
        for j := 0; j < n; j++ {
            temp := dp[j+1]
            if matrix[i][j] == '1' {
                dp[j+1] = min(min(dp[j+1], dp[j]), prev) + 1
                if dp[j+1] > maxSide {
                    maxSide = dp[j+1]
                }
            } else {
                dp[j+1] = 0
            }
            prev = temp
        }
        prev = 0 // 每行开始前重置 prev
    }
    return maxSide * maxSide
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```


> 💡 **说明**：  
> - Java 版使用清晰的二维 DP，易于理解  
> - Go 版采用空间优化（O(n) 空间），利用 `prev` 保存左上角值

---

### 示例演示

以示例 1 为例：

原始矩阵：
```

1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

```

DP 表构建过程（仅显示非零部分）：
```

1 0 1 0 0
1 0 1 1 1
1 1 1 2 2
1 0 0 1 0

```

最大值为 `2` → 面积 = `2² = 4` ✅

---

### 答案有效性证明

**归纳法证明 DP 正确性**：

- **基础**：当 `i=0` 或 `j=0`，最大正方形边长只能是 0 或 1，与 `matrix[i][j]` 一致。
- **归纳假设**：假设对所有 `(i', j')` 满足 `i' < i` 或 `j' < j`，`dp[i'][j']` 正确。
- **归纳步骤**：  
  若 `matrix[i][j] == '1'`，则以 `(i,j)` 为右下角的正方形边长受限于左、上、左上三个方向的最小边长 + 1。  
  因为只有当这三个方向都能形成 `k×k` 正方形时，`(i,j)` 才能形成 `(k+1)×(k+1)` 正方形。

因此，DP 转移正确。

---

### 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 |
|------|-----------|-----------|
| 标准 DP | O(mn) | O(mn) |
| 空间优化 DP | O(mn) | O(n) |

其中 `m = matrix.length`, `n = matrix[0].length`

---

### 问题总结

✅ **关键点**：
- 最大正方形问题具有**最优子结构**，适合 DP
- 状态转移依赖**左、上、左上**三个邻居
- 空间可优化至 O(n)，但二维 DP 更直观

💡 **技巧**：
- 使用 `dp` 记录**边长**而非面积，简化转移
- 边界条件单独处理（首行/首列）

📌 **适用场景**：
- 二维网格中求最大/最小满足条件的子结构
- 子结构具有“连续性”和“局部依赖性”

此题是 DP 在二维网格中的经典应用，掌握后可迁移到类似问题（如最大矩形、岛屿问题等）。
