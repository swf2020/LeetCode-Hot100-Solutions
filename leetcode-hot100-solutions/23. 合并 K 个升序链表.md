# åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨ï¼ˆLeetCode 23ï¼‰

## é—®é¢˜ç®€ä»‹

ğŸ”— [LeetCode 23. åˆå¹¶ K ä¸ªå‡åºé“¾è¡¨](https://leetcode.cn/problems/merge-k-sorted-lists?envType=problem-list-v2&envId=2cktkvj)

### é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªé“¾è¡¨æ•°ç»„ï¼Œæ¯ä¸ªé“¾è¡¨éƒ½å·²ç»æŒ‰å‡åºæ’åˆ—ã€‚

è¯·ä½ å°†æ‰€æœ‰é“¾è¡¨åˆå¹¶åˆ°ä¸€ä¸ªå‡åºé“¾è¡¨ä¸­ï¼Œè¿”å›åˆå¹¶åçš„é“¾è¡¨ã€‚

______________________________________________________________________

## ç¤ºä¾‹è¯´æ˜

### ç¤ºä¾‹ 1ï¼š

**è¾“å…¥ï¼š**\
`lists = [[1,4,5],[1,3,4],[2,6]]`

**è¾“å‡ºï¼š**\
`[1,1,2,3,4,4,5,6]`

**è§£é‡Šï¼š**\
é“¾è¡¨æ•°ç»„å¦‚ä¸‹ï¼š

```
[
  1->4->5,
  1->3->4,
  2->6
]
```

å°†å®ƒä»¬åˆå¹¶åˆ°ä¸€ä¸ªæœ‰åºé“¾è¡¨ä¸­å¾—åˆ° `1->1->2->3->4->4->5->6`ã€‚

______________________________________________________________________

### ç¤ºä¾‹ 2ï¼š

**è¾“å…¥ï¼š**\
`lists = []`

**è¾“å‡ºï¼š**\
`[]`

______________________________________________________________________

### ç¤ºä¾‹ 3ï¼š

**è¾“å…¥ï¼š**\
`lists = [[]]`

**è¾“å‡ºï¼š**\
`[]`

______________________________________________________________________

## è§£é¢˜æ€è·¯

### âœ… æ–¹æ³•ä¸€ï¼šé¡ºåºåˆå¹¶ï¼ˆä¸¤ä¸¤åˆå¹¶ï¼‰

- **æ€è·¯**ï¼šä»ç¬¬ä¸€ä¸ªé“¾è¡¨å¼€å§‹ï¼Œä¾æ¬¡ä¸ä¸‹ä¸€ä¸ªé“¾è¡¨åˆå¹¶ã€‚
- **æ­¥éª¤**ï¼š
  1. åˆå§‹åŒ–ç»“æœé“¾è¡¨ä¸º `null`ã€‚
  1. éå† `lists`ï¼Œæ¯æ¬¡å°†å½“å‰ç»“æœä¸ `lists[i]` åˆå¹¶ã€‚
  1. åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ä½¿ç”¨ç»å…¸åŒæŒ‡é’ˆæ³•ã€‚

> âš ï¸ ç¼ºç‚¹ï¼šæ—¶é—´å¤æ‚åº¦è¾ƒé«˜ï¼Œå› ä¸ºå‰é¢çš„é“¾è¡¨ä¼šè¢«åå¤éå†ã€‚

______________________________________________________________________

### âœ… æ–¹æ³•äºŒï¼šåˆ†æ²»åˆå¹¶ï¼ˆæ¨èï¼‰

- **æ€è·¯**ï¼šé‡‡ç”¨åˆ†æ²»ç­–ç•¥ï¼Œå°† K ä¸ªé“¾è¡¨ä¸¤ä¸¤é…å¯¹åˆå¹¶ï¼Œç›´åˆ°åªå‰©ä¸€ä¸ªé“¾è¡¨ã€‚
- **æ­¥éª¤**ï¼š
  1. å¦‚æœ `lists` ä¸ºç©ºï¼Œè¿”å› `null`ã€‚
  1. é€’å½’åœ°å°†é“¾è¡¨æ•°ç»„åˆ†æˆä¸¤åŠï¼Œåˆ†åˆ«åˆå¹¶ã€‚
  1. åˆå¹¶å·¦å³ä¸¤éƒ¨åˆ†çš„ç»“æœã€‚

> ğŸ’¡ ç±»ä¼¼äºå½’å¹¶æ’åºçš„æ€æƒ³ï¼Œå‡å°‘é‡å¤æ¯”è¾ƒã€‚

______________________________________________________________________

### âœ… æ–¹æ³•ä¸‰ï¼šä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰

- **æ€è·¯**ï¼šç»´æŠ¤ä¸€ä¸ªå¤§å°ä¸º K çš„æœ€å°å †ï¼Œæ¯æ¬¡å–å‡ºæœ€å°èŠ‚ç‚¹åŠ å…¥ç»“æœã€‚
- **æ­¥éª¤**ï¼š
  1. å°†æ¯ä¸ªéç©ºé“¾è¡¨çš„å¤´èŠ‚ç‚¹åŠ å…¥æœ€å°å †ã€‚
  1. å¼¹å‡ºå †é¡¶ï¼ˆæœ€å°å€¼ï¼‰ï¼ŒåŠ å…¥ç»“æœé“¾è¡¨ã€‚
  1. è‹¥å¼¹å‡ºèŠ‚ç‚¹æœ‰ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå°†å…¶åŠ å…¥å †ã€‚
  1. é‡å¤ç›´åˆ°å †ä¸ºç©ºã€‚

> ğŸ’¡ æ—¶é—´å¤æ‚åº¦æœ€ä¼˜ï¼Œé€‚åˆ K è¾ƒå¤§çš„æƒ…å†µã€‚

______________________________________________________________________

## ä»£ç å®ç°

<div class="code-tabs">

```java:Java
// æ–¹æ³•ä¸€ï¼šé¡ºåºåˆå¹¶
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        ListNode res = null;
        for (ListNode list : lists) {
            res = mergeTwoLists(res, list);
        }
        return res;
    }

    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null) return l2;
        if (l2 == null) return l1;
        if (l1.val < l2.val) {
            l1.next = mergeTwoLists(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeTwoLists(l1, l2.next);
            return l2;
        }
    }
}

// æ–¹æ³•äºŒï¼šåˆ†æ²»åˆå¹¶
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        return merge(lists, 0, lists.length - 1);
    }

    private ListNode merge(ListNode[] lists, int l, int r) {
        if (l == r) return lists[l];
        int mid = l + (r - l) / 2;
        ListNode left = merge(lists, l, mid);
        ListNode right = merge(lists, mid + 1, r);
        return mergeTwoLists(left, right);
    }

    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        cur.next = (l1 != null) ? l1 : l2;
        return dummy.next;
    }
}

// æ–¹æ³•ä¸‰ï¼šä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if (lists == null || lists.length == 0) return null;
        
        PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
        for (ListNode node : lists) {
            if (node != null) pq.offer(node);
        }

        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        while (!pq.isEmpty()) {
            ListNode node = pq.poll();
            cur.next = node;
            cur = cur.next;
            if (node.next != null) {
                pq.offer(node.next);
            }
        }
        return dummy.next;
    }
}
```

```go:Go
// æ–¹æ³•ä¸€ï¼šé¡ºåºåˆå¹¶
func mergeKLists(lists []*ListNode) *ListNode {
    var res *ListNode
    for _, list := range lists {
        res = mergeTwoLists(res, list)
    }
    return res
}

func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    if l1 == nil {
        return l2
    }
    if l2 == nil {
        return l1
    }
    if l1.Val < l2.Val {
        l1.Next = mergeTwoLists(l1.Next, l2)
        return l1
    } else {
        l2.Next = mergeTwoLists(l1, l2.Next)
        return l2
    }
}

// æ–¹æ³•äºŒï¼šåˆ†æ²»åˆå¹¶
func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }
    return merge(lists, 0, len(lists)-1)
}

func merge(lists []*ListNode, l, r int) *ListNode {
    if l == r {
        return lists[l]
    }
    mid := l + (r-l)/2
    left := merge(lists, l, mid)
    right := merge(lists, mid+1, r)
    return mergeTwoLists(left, right)
}

func mergeTwoLists(l1, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    cur := dummy
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            cur.Next = l1
            l1 = l1.Next
        } else {
            cur.Next = l2
            l2 = l2.Next
        }
        cur = cur.Next
    }
    if l1 != nil {
        cur.Next = l1
    } else {
        cur.Next = l2
    }
    return dummy.Next
}

// æ–¹æ³•ä¸‰ï¼šä¼˜å…ˆé˜Ÿåˆ—ï¼ˆæœ€å°å †ï¼‰
import "container/heap"

type minHeap []*ListNode

func (h minHeap) Len() int           { return len(h) }
func (h minHeap) Less(i, j int) bool { return h[i].Val < h[j].Val }
func (h minHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *minHeap) Push(x interface{}) { *h = append(*h, x.(*ListNode)) }
func (h *minHeap) Pop() interface{} {
    old := *h
    n := len(old)
    x := old[n-1]
    *h = old[0 : n-1]
    return x
}

func mergeKLists(lists []*ListNode) *ListNode {
    if len(lists) == 0 {
        return nil
    }

    h := &minHeap{}
    heap.Init(h)
    for _, node := range lists {
        if node != nil {
            heap.Push(h, node)
        }
    }

    dummy := &ListNode{}
    cur := dummy
    for h.Len() > 0 {
        node := heap.Pop(h).(*ListNode)
        cur.Next = node
        cur = cur.Next
        if node.Next != nil {
            heap.Push(h, node.Next)
        }
    }
    return dummy.Next
}
```

</div>

______________________________________________________________________

## ç¤ºä¾‹æ¼”ç¤º

ä»¥ `lists = [[1,4,5],[1,3,4],[2,6]]` ä¸ºä¾‹ï¼Œä½¿ç”¨**åˆ†æ²»æ³•**ï¼š

1. åˆ†æˆ `[ [1,4,5], [1,3,4] ]` å’Œ `[ [2,6] ]`
1. å·¦è¾¹å†åˆ†ï¼š`[1,4,5]` ä¸ `[1,3,4]` åˆå¹¶ â†’ `[1,1,3,4,4,5]`
1. å³è¾¹ç›´æ¥æ˜¯ `[2,6]`
1. æœ€ç»ˆåˆå¹¶ `[1,1,3,4,4,5]` ä¸ `[2,6]` â†’ `[1,1,2,3,4,4,5,6]`

______________________________________________________________________

## ç­”æ¡ˆæœ‰æ•ˆæ€§è¯æ˜

- **æ­£ç¡®æ€§**ï¼š
  - æ‰€æœ‰æ–¹æ³•éƒ½åŸºäºâ€œåˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨â€çš„æ­£ç¡®å­ç¨‹åºã€‚
  - åˆ†æ²»å’Œä¼˜å…ˆé˜Ÿåˆ—ç¡®ä¿æ¯æ¬¡å–å…¨å±€æœ€å°å€¼ï¼Œç»´æŒå‡åºã€‚
- **è¾¹ç•Œå¤„ç†**ï¼š
  - ç©ºæ•°ç»„ã€ç©ºé“¾è¡¨å‡è¢«æ­£ç¡®å¤„ç†ï¼ˆè¿”å› `null` æˆ– `nil`ï¼‰ã€‚
- **LeetCode æµ‹è¯•é€šè¿‡**ï¼šä¸‰ç§æ–¹æ³•å‡å¯ ACã€‚

______________________________________________________________________

## å¤æ‚åº¦åˆ†æ

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | è¯´æ˜ |
|------|------------|------------|------|
| é¡ºåºåˆå¹¶ | $O(kN)$ | $O(1)$ | $N$ ä¸ºå¹³å‡é“¾è¡¨é•¿åº¦ï¼Œæœ€åéœ€åˆå¹¶ $k$ æ¬¡ï¼Œæ¯æ¬¡ $O(N)$ |
| åˆ†æ²»åˆå¹¶ | $O(N \\log k)$ | $O(\\log k)$ | é€’å½’æ·±åº¦ $\\log k$ï¼Œæ¯å±‚æ€»åˆå¹¶ä»£ä»· $O(N)$ |
| ä¼˜å…ˆé˜Ÿåˆ— | $O(N \\log k)$ | $O(k)$ | æ¯ä¸ªèŠ‚ç‚¹å…¥å †ä¸€æ¬¡ï¼Œå †æ“ä½œ $O(\\log k)$ |

> âœ… **æ¨èä½¿ç”¨åˆ†æ²»æˆ–ä¼˜å…ˆé˜Ÿåˆ—**ï¼Œå°¤å…¶å½“ $k$ è¾ƒå¤§æ—¶ã€‚

______________________________________________________________________

## é—®é¢˜æ€»ç»“

- **æ ¸å¿ƒæ€æƒ³**ï¼šå°†å¤šè·¯å½’å¹¶è½¬åŒ–ä¸ºä¸¤ä¸¤å½’å¹¶æˆ–åˆ©ç”¨å †ç»“æ„é«˜æ•ˆå–æœ€å°å€¼ã€‚
- **å…³é”®æŠ€å·§**ï¼š
  - åˆ†æ²»é™ä½é‡å¤è®¡ç®—ï¼›
  - æœ€å°å †åŠ¨æ€ç»´æŠ¤å½“å‰å€™é€‰æœ€å°å€¼ã€‚
- **é€‚ç”¨åœºæ™¯**ï¼š
  - å¤–éƒ¨æ’åºï¼ˆå¦‚å¤§æ•°æ®å½’å¹¶ï¼‰ï¼›
  - å¤šè·¯æ—¥å¿—åˆå¹¶ã€äº‹ä»¶æµå¤„ç†ç­‰ã€‚
