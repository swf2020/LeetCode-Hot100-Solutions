# 234. 回文链表

[LeetCode 题目链接](https://leetcode.cn/problems/palindrome-linked-list?envType=problem-list-v2&envId=2cktkvj)

## ❓ 问题简介

给你一个单链表的头节点 `head`，请你判断该链表是否为**回文链表**。

如果是，返回 `true`；否则，返回 `false`。

> **回文链表**：正着读和反着读都一样的链表。

### 📌 题目描述

- 链表中节点数目范围是 `[1, 10⁵]`
- `0 <= Node.val <= 9`

______________________________________________________________________

## 🧪 示例说明

### 示例 1：

```
输入：head = [1,2,2,1]
输出：true
```

### 示例 2：

```
输入：head = [1,2]
输出：false
```

### 示例 3：

```
输入：head = [1,2,3,2,1]
输出：true
```

______________________________________________________________________

## 💡 解题思路

要判断一个链表是否为回文，核心思想是**比较前半部分与后半部分是否对称**。由于链表只能单向遍历，我们需要一些技巧来实现“从后往前”比较。

### ✅ 方法一：使用栈（辅助空间）

1. 遍历链表，将所有节点值压入栈。
1. 再次遍历链表，同时弹出栈顶元素，逐个比较。
1. 若全部相等，则为回文。

> **优点**：思路简单\
> **缺点**：需要 O(n) 额外空间

______________________________________________________________________

### ✅ 方法二：反转后半部分链表（最优解）

这是 LeetCode 官方推荐的 **O(1) 空间** 解法：

1. **找中点**：使用快慢指针（快指针走两步，慢指针走一步），找到链表中点。
   - 奇数长度：慢指针停在中间（如 `[1,2,3,2,1]` → 指向 `3`）
   - 偶数长度：慢指针停在前半段末尾（如 `[1,2,2,1]` → 指向第一个 `2`）
1. **反转后半部分**：从慢指针的下一个节点开始反转。
1. **双指针比较**：一个从头开始，一个从反转后的后半部分开始，逐个比较。
1. **（可选）恢复链表**：题目不要求，但实际工程中建议恢复原结构。

> **优点**：空间复杂度 O(1)，符合进阶要求\
> **关键点**：正确处理奇偶长度、反转链表、比较逻辑

______________________________________________________________________

### ❌ 方法三：转为数组再判断（不推荐）

虽然可行，但违背了“链表”题目的本意，且空间复杂度 O(n)。

______________________________________________________________________

## 💻 代码实现

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        if (head == null || head.next == null) return true;

        // Step 1: 找中点（快慢指针）
        ListNode slow = head, fast = head;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }

        // Step 2: 反转后半部分
        ListNode secondHalf = reverseList(slow.next);
        slow.next = null; // 断开前后两部分（可选）

        // Step 3: 比较前半部分和反转后的后半部分
        ListNode p1 = head, p2 = secondHalf;
        boolean result = true;
        while (p2 != null) {
            if (p1.val != p2.val) {
                result = false;
                break;
            }
            p1 = p1.next;
            p2 = p2.next;
        }

        // Step 4: 恢复链表（可选，题目不要求）
        slow.next = reverseList(secondHalf);

        return result;
    }

    private ListNode reverseList(ListNode head) {
        ListNode prev = null, curr = head;
        while (curr != null) {
            ListNode next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
}
```

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func isPalindrome(head *ListNode) bool {
    if head == nil || head.Next == nil {
        return true
    }

    // Step 1: 找中点（快慢指针）
    slow, fast := head, head
    for fast.Next != nil && fast.Next.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    // Step 2: 反转后半部分
    secondHalf := reverseList(slow.Next)
    slow.Next = nil // 断开（可选）

    // Step 3: 比较
    p1, p2 := head, secondHalf
    result := true
    for p2 != nil {
        if p1.Val != p2.Val {
            result = false
            break
        }
        p1 = p1.Next
        p2 = p2.Next
    }

    // Step 4: 恢复链表（可选）
    slow.Next = reverseList(secondHalf)

    return result
}

func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

______________________________________________________________________

## 🎯 示例演示

以 `head = [1,2,2,1]` 为例：

1. **找中点**：

   - 初始：`slow=1`, `fast=1`
   - 第一次：`slow=2`, `fast=2`（`fast.Next.Next = null`，停止）
   - 中点为第一个 `2`

1. **反转后半部分**：

   - 后半部分：`[2,1]` → 反转后：`[1,2]`

1. **比较**：

   - `p1=1` vs `p2=1` → 相等
   - `p1=2` vs `p2=2` → 相等
   - `p2` 为 `null`，结束 → 返回 `true`

______________________________________________________________________

## ✅ 答案有效性证明

| 情况 | 处理方式 | 正确性 |
|------|--------|-------|
| **空链表 / 单节点** | 直接返回 `true` | ✅ |
| **偶数长度** | 中点为前半段末尾，后半段完整反转 | ✅ |
| **奇数长度** | 中点为中间节点，后半段从 `mid+1` 开始，中间节点不参与比较 | ✅ |
| **非回文** | 比较时发现不等，立即返回 `false` | ✅ |

> **关键保证**：快慢指针确保 `slow` 停在正确位置，无论奇偶。

______________________________________________________________________

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 是否满足进阶要求 |
|------|-----------|-----------|----------------|
| 栈（辅助空间） | O(n) | O(n) | ❌ |
| **反转后半部分** | **O(n)** | **O(1)** | ✅ |
| 转数组 | O(n) | O(n) | ❌ |

> **说明**：
>
> - 时间：找中点 O(n/2)，反转 O(n/2)，比较 O(n/2) → 总计 O(n)
> - 空间：仅用几个指针变量 → O(1)

______________________________________________________________________

## 🧠 问题总结

- **核心思想**：利用**快慢指针找中点 + 反转链表**，实现 O(1) 空间判断回文。
- **易错点**：
  - 快慢指针终止条件（`fast.next` 和 `fast.next.next` 都要检查）
  - 奇数长度时中间节点不参与比较
  - 反转链表的边界处理
- **工程建议**：若题目允许修改链表，可不恢复；否则应在比较后恢复原结构。
- **延伸思考**：此方法也适用于判断**回文字符串**（双指针），但链表无法随机访问，故需反转技巧。

> 💡 **记住**：链表回文问题的最优解 = **快慢指针 + 反转后半段**！
