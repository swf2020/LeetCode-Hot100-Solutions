# 问题简介

[LeetCode 236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

## 示例说明

### 示例 1：

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
输出：3
解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
```

### 示例 2：

```
输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
输出：5
解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
```

### 示例 3：

```
输入：root = [1,2], p = 1, q = 2
输出：1
```

# 解题思路

## 方法一：递归法（后序遍历）✅

💡 **核心思想**：自底向上查找，利用后序遍历的特性

### 步骤分析：

1. **递归终止条件**：

   - 如果当前节点为空，返回 null
   - 如果当前节点等于 p 或 q，直接返回当前节点

1. **递归过程**：

   - 在左子树中查找 p 和 q
   - 在右子树中查找 p 和 q

1. **结果判断**：

   - 如果 left 和 right 都不为空，说明 p 和 q 分别在左右子树中，当前节点就是 LCA
   - 如果 left 不为空而 right 为空，说明 p 和 q 都在左子树中，返回 left
   - 如果 left 为空而 right 不为空，说明 p 和 q 都在右子树中，返回 right
   - 如果都为空，返回 null

## 方法二：存储父节点 + 路径回溯 ❌

虽然可行，但空间复杂度较高，不如方法一优雅。

### 步骤：

1. 使用哈希表存储每个节点的父节点
1. 从 p 开始向上遍历到根节点，记录所有祖先节点
1. 从 q 开始向上遍历，第一个出现在 p 的祖先集合中的节点就是 LCA

## 方法三：路径比较法 ❌

1. 分别找到从根到 p 和 q 的路径
1. 比较两条路径，最后一个相同的节点就是 LCA

📌 **推荐使用方法一**，代码简洁，效率高，符合二叉树递归的天然特性。

# 代码实现

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // 递归终止条件
        if (root == null || root == p || root == q) {
            return root;
        }
        
        // 在左右子树中查找
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        
        // 判断结果
        if (left != null && right != null) {
            // p 和 q 分别在左右子树中
            return root;
        } else if (left != null) {
            // p 和 q 都在左子树中
            return left;
        } else if (right != null) {
            // p 和 q 都在右子树中
            return right;
        } else {
            // p 和 q 都不在当前子树中
            return null;
        }
    }
}
```

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    // 递归终止条件
    if root == nil || root == p || root == q {
        return root
    }
    
    // 在左右子树中查找
    left := lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    
    // 判断结果
    if left != nil && right != nil {
        // p 和 q 分别在左右子树中
        return root
    } else if left != nil {
        // p 和 q 都在左子树中
        return left
    } else if right != nil {
        // p 和 q 都在右子树中
        return right
    } else {
        // p 和 q 都不在当前子树中
        return nil
    }
}
```


# 示例演示

让我们以示例1为例进行演示：

```
   3
  / \
 5   1
/ \ / \
6 2 0 8
/ \
7 4

```

查找 p=5, q=1 的 LCA：

1. **root=3**: 
   - left = LCA(5, 5, 1) → 返回 5
   - right = LCA(1, 5, 1) → 返回 1
   - left≠null 且 right≠null → 返回 3

2. **root=5**:
   - root == p → 直接返回 5

3. **root=1**:
   - root == q → 直接返回 1

最终结果：3 ✅

# 答案有效性证明

## 正确性分析：

1. **基础情况**：当节点为空或等于 p/q 时，直接返回，这是正确的
2. **归纳假设**：假设对左右子树的递归调用都能正确返回 LCA 或找到的节点
3. **归纳步骤**：
   - 如果 p 和 q 在不同子树中，当前节点必然是 LCA
   - 如果 p 和 q 在同一子树中，递归会继续向下查找直到找到分叉点
   - 如果只找到一个节点，说明另一个节点在其子树中，该节点就是 LCA

## 边界情况验证：

| 情况 | 处理方式 | 结果 |
|------|----------|------|
| p 或 q 为根节点 | 直接返回根节点 | ✅ |
| p 是 q 的祖先 | 返回 p | ✅ |
| q 是 p 的祖先 | 返回 q | ✅ |
| p 和 q 无公共祖先 | 不可能（题目保证在同一棵树中） | - |

# 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 递归法 | O(n) | O(n) | 最坏情况下需要遍历所有节点，递归栈深度为树的高度 |
| 存储父节点法 | O(n) | O(n) | 需要额外的哈希表存储父节点信息 |
| 路径比较法 | O(n) | O(n) | 需要存储两条路径 |

💡 **最优解**：递归法，代码最简洁，常数因子最小。

# 问题总结

✅ **关键洞察**：
- 利用后序遍历的自底向上特性
- 通过左右子树的返回值判断 LCA 位置
- 一个节点可以是自己的祖先

✅ **解题模板**：
- 递归终止条件处理
- 左右子树递归调用
- 根据子树结果进行逻辑判断

✅ **适用场景**：
- 二叉树中查找公共祖先问题
- 需要自底向上信息传递的场景
- 树的路径相关问题

📌 **记忆要点**：**"左右都有就返回根，只有一个就返回那个，都没有就返回空"**
