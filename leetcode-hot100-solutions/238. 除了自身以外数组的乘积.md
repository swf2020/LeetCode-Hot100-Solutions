### 问题简介

🔗 [LeetCode 238. 除了自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self?envType=problem-list-v2&envId=2cktkvj)

#### 题目描述

给你一个整数数组 `nums`，返回一个数组 `answer`，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积。

**要求：**

- **不能使用除法**
- **时间复杂度为 O(n)**
- **空间复杂度为 O(1)**（输出数组不计入额外空间）

______________________________________________________________________

### 示例说明

📌 **示例 1：**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

解释：

- answer[0] = 2×3×4 = 24
- answer[1] = 1×3×4 = 12
- answer[2] = 1×2×4 = 8
- answer[3] = 1×2×3 = 6

📌 **示例 2：**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

______________________________________________________________________

### 解题思路

💡 **核心思想：**\
每个位置的结果 = **左边所有元素的乘积 × 右边所有元素的乘积**

我们可以分两步完成：

#### ✅ 方法一：左右乘积数组（辅助空间 O(n)，便于理解）

1. 创建两个数组 `left` 和 `right`：
   - `left[i]` 表示 `nums[0] × ... × nums[i-1]`
   - `right[i]` 表示 `nums[i+1] × ... × nums[n-1]`
1. 最终结果 `answer[i] = left[i] × right[i]`

> 此方法直观，但空间复杂度为 O(n)，不符合题目“O(1) 额外空间”要求。

______________________________________________________________________

#### ✅✅ 方法二：原地优化（空间 O(1)，符合要求）

利用输出数组 `answer` 先存储**左侧乘积**，再用一个变量动态维护**右侧乘积**，从右向左遍历更新。

**步骤详解：**

1. 初始化 `answer` 数组，长度为 n。
1. 第一次遍历（从左到右）：
   - `answer[0] = 1`
   - `answer[i] = answer[i-1] * nums[i-1]` → 存储左侧乘积
1. 初始化 `rightProduct = 1`
1. 第二次遍历（从右到左）：
   - `answer[i] = answer[i] * rightProduct` → 左侧 × 右侧
   - 更新 `rightProduct *= nums[i]`

📌 **关键点：**

- 输出数组不算额外空间，因此可复用。
- 两次遍历，每次 O(n)，总时间 O(n)
- 仅用一个变量 `rightProduct`，空间 O(1)

______________________________________________________________________

### 多种解法对比

| 方法 | 时间复杂度 | 空间复杂度（不含输出） | 是否符合要求 |
|------|------------|------------------------|--------------|
| ❌ 暴力法（双重循环） | O(n²) | O(1) | ❌ 超时 |
| ⚠️ 左右乘积数组 | O(n) | O(n) | ❌ 空间超标 |
| ✅ 原地优化（推荐） | O(n) | O(1) | ✅ 完全符合 |

______________________________________________________________________

### 代码实现

<div class="code-tabs">

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int n = nums.length;
        int[] answer = new int[n];
        
        // 第一步：计算左侧乘积
        answer[0] = 1;
        for (int i = 1; i < n; i++) {
            answer[i] = answer[i - 1] * nums[i - 1];
        }
        
        // 第二步：从右向左，用 rightProduct 累乘右侧
        int rightProduct = 1;
        for (int i = n - 1; i >= 0; i--) {
            answer[i] *= rightProduct;
            rightProduct *= nums[i];
        }
        
        return answer;
    }
}
```

```go 
func productExceptSelf(nums []int) []int {
    n := len(nums)
    answer := make([]int, n)
    
    // 第一步：计算左侧乘积
    answer[0] = 1
    for i := 1; i < n; i++ {
        answer[i] = answer[i-1] * nums[i-1]
    }
    
    // 第二步：从右向左，用 rightProduct 累乘右侧
    rightProduct := 1
    for i := n - 1; i >= 0; i-- {
        answer[i] *= rightProduct
        rightProduct *= nums[i]
    }
    
    return answer
}
```

</div>

______________________________________________________________________

### 示例演示（以 `[1,2,3,4]` 为例）

| 步骤 | `answer` 数组状态 | `rightProduct` |
|------|-------------------|----------------|
| 初始 | `[1, ?, ?, ?]` | - |
| 左侧遍历后 | `[1, 1, 2, 6]` | - |
| i=3（右→左） | `[1, 1, 2, 6]` → `[1,1,2,6*1=6]` | `1 → 4` |
| i=2 | `[1,1,2*4=8,6]` | `4 → 12` |
| i=1 | `[1,1*12=12,8,6]` | `12 → 24` |
| i=0 | `[1*24=24,12,8,6]` | `24` |

✅ 最终结果：`[24,12,8,6]`

______________________________________________________________________

### 答案有效性证明

我们需证明：对任意 `i ∈ [0, n-1]`，`answer[i] = ∏_{j≠i} nums[j]`

- **左侧乘积阶段**：`answer[i] = nums[0] × ... × nums[i-1]`
- **右侧乘积阶段**：乘上 `rightProduct = nums[i+1] × ... × nums[n-1]`
- 因此 `answer[i] = (∏_{j=0}^{i-1} nums[j]) × (∏_{j=i+1}^{n-1} nums[j]) = ∏_{j≠i} nums[j]`

✅ 数学归纳与遍历逻辑保证正确性。

即使数组含 **0**（如示例2），算法依然正确：

- 若有多个 0 → 所有 answer[i] = 0
- 若有一个 0 → 仅该位置非零（其他位置因乘了 0 而为 0）

______________________________________________________________________

### 复杂度分析

| 项目 | 分析 |
|------|------|
| **时间复杂度** | 两次遍历数组，O(n) + O(n) = **O(n)** |
| **空间复杂度** | 仅使用常数变量 `rightProduct`，输出数组不计 → **O(1)** |
| **是否修改输入** | 否，只读 `nums` |
| **稳定性** | 对负数、零、大数均适用 |

______________________________________________________________________

### 问题总结

✅ **本题核心在于“拆分乘积为左右两部分”**，避免除法和嵌套循环。

📌 **关键技巧：**

- 利用输出数组作为临时存储（常见于 O(1) 空间要求题）
- 两次单向遍历分别处理左右信息
- 动态维护一侧乘积（如 `rightProduct`）

💡 **延伸思考：**

- 若允许除法？→ 需特殊处理 0（一个 0 或多个 0）
- 若要求模大质数下的乘积？→ 需逆元，但本题禁止除法即暗示不用此法

此解法优雅、高效，是前缀/后缀乘积思想的经典应用。
