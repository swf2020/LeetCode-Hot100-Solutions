# ❌|✅|💡|📌 279. 完全平方数

## 🔗 问题简介

[LeetCode 279. 完全平方数](https://leetcode.cn/problems/perfect-squares?envType=problem-list-v2&envId=2cktkvj)

### 题目描述

给你一个整数 `n`，返回 **和为 `n` 的完全平方数的最少数量**。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

______________________________________________________________________

## 📌 示例说明

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**示例 3：**

```
输入：n = 1
输出：1
```

______________________________________________________________________

## 💡 解题思路

本题本质上是一个**最短路径问题**或**最小硬币找零问题**的变种 —— 给定目标值 `n`，用最少数量的“完全平方数”（可重复使用）加起来等于 `n`。

### ✅ 方法一：动态规划（DP）

#### 思路步骤：

1. **定义状态**：设 `dp[i]` 表示组成数字 `i` 所需的最少完全平方数个数。
1. **初始化**：
   - `dp[0] = 0`（0 不需要任何平方数）
   - 其余 `dp[i] = ∞`（或一个较大值，如 `i`，因为最坏情况是 `1+1+...+1` 共 `i` 次）
1. **状态转移**：
   - 对于每个 `i` 从 `1` 到 `n`，
   - 枚举所有满足 `j*j <= i` 的 `j`，
   - 更新：`dp[i] = min(dp[i], dp[i - j*j] + 1)`
1. **返回结果**：`dp[n]`

> 时间复杂度较高，但逻辑清晰，易于理解。

______________________________________________________________________

### ✅ 方法二：BFS（广度优先搜索）

#### 思路步骤：

1. 将问题看作从 `n` 出发，每次减去一个完全平方数，直到变为 `0`。
1. 每一层 BFS 代表使用了相同数量的平方数。
1. 第一次到达 `0` 时的层数即为答案。
1. 使用队列和 visited 集合避免重复计算。

> 由于 BFS 天然求最短路径，此方法在很多情况下比 DP 更快。

______________________________________________________________________

### ✅ 方法三：数学解法（四平方和定理）

#### 背景知识（拉格朗日四平方和定理）：

> 任何一个正整数都可以表示为 **至多 4 个** 完全平方数之和。

因此，答案只能是 1、2、3 或 4。

进一步优化：

- 若 `n` 本身就是完全平方数 → 返回 1。
- 若 `n` 可表示为两个平方数之和 → 返回 2。
- 若 `n` 满足 **勒让德三平方定理**：`n = 4^a * (8b + 7)` → 必须用 4 个 → 返回 4。
- 否则 → 返回 3。

> 此方法时间复杂度 O(√n)，最优解！

______________________________________________________________________

## 💻 代码实现

<div class="code-tabs">

```java:Java
// 方法一：动态规划
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j * j <= i; j++) {
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);
            }
        }
        return dp[n];
    }
}

// 方法二：BFS
class Solution {
    public int numSquares(int n) {
        Queue<Integer> queue = new LinkedList<>();
        Set<Integer> visited = new HashSet<>();
        queue.offer(n);
        visited.add(n);
        int level = 0;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            level++;
            for (int i = 0; i < size; i++) {
                int cur = queue.poll();
                for (int j = 1; j * j <= cur; j++) {
                    int next = cur - j * j;
                    if (next == 0) return level;
                    if (!visited.contains(next)) {
                        visited.add(next);
                        queue.offer(next);
                    }
                }
            }
        }
        return level;
    }
}

// 方法三：数学解法
class Solution {
    public int numSquares(int n) {
        // 检查是否为完全平方数
        if (isPerfectSquare(n)) return 1;
        
        // 检查是否能表示为两个平方数之和
        if (checkTwoSquares(n)) return 2;
        
        // 检查是否满足 4^a*(8b+7)
        while (n % 4 == 0) {
            n /= 4;
        }
        if (n % 8 == 7) return 4;
        
        return 3;
    }
    
    private boolean isPerfectSquare(int x) {
        int sqrt = (int) Math.sqrt(x);
        return sqrt * sqrt == x;
    }
    
    private boolean checkTwoSquares(int n) {
        for (int i = 1; i * i <= n; i++) {
            if (isPerfectSquare(n - i * i)) {
                return true;
            }
        }
        return false;
    }
}
```

```go:Go
// 方法一：动态规划
func numSquares(n int) int {
    dp := make([]int, n+1)
    for i := 1; i <= n; i++ {
        dp[i] = i // 最坏情况：全用1
        for j := 1; j*j <= i; j++ {
            dp[i] = min(dp[i], dp[i-j*j]+1)
        }
    }
    return dp[n]
}

// 方法二：BFS
func numSquares(n int) int {
    queue := []int{n}
    visited := make(map[int]bool)
    visited[n] = true
    level := 0
    
    for len(queue) > 0 {
        level++
        size := len(queue)
        for i := 0; i < size; i++ {
            cur := queue[0]
            queue = queue[1:]
            for j := 1; j*j <= cur; j++ {
                next := cur - j*j
                if next == 0 {
                    return level
                }
                if !visited[next] {
                    visited[next] = true
                    queue = append(queue, next)
                }
            }
        }
    }
    return level
}

// 方法三：数学解法
func numSquares(n int) int {
    if isPerfectSquare(n) {
        return 1
    }
    if checkTwoSquares(n) {
        return 2
    }
    // 去除因子4
    temp := n
    for temp%4 == 0 {
        temp /= 4
    }
    if temp%8 == 7 {
        return 4
    }
    return 3
}

func isPerfectSquare(x int) bool {
    sqrt := int(math.Sqrt(float64(x)))
    return sqrt*sqrt == x
}

func checkTwoSquares(n int) bool {
    for i := 1; i*i <= n; i++ {
        if isPerfectSquare(n - i*i) {
            return true
        }
    }
    return false
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

</div>

______________________________________________________________________

## 🧪 示例演示

以 `n = 12` 为例：

- **DP 过程**：

  - `dp[1] = 1`（1）
  - `dp[2] = 2`（1+1）
  - ...
  - `dp[4] = 1`（4）
  - `dp[8] = 2`（4+4）
  - `dp[12] = min(dp[12-1]+1, dp[12-4]+1, dp[12-9]+1) = min(12, dp[8]+1=3, dp[3]+1=4) = 3`

- **BFS 过程**：

  - Level 1: 12 → [11, 8, 3]
  - Level 2: 11→[10,7,2], 8→[7,4,-1], 3→[2,-1]
  - Level 3: 从 8 得到 4，再从 4 得到 0 → 返回 3

- **数学法**：

  - 12 不是平方数
  - 检查两平方：12-1=11（非平方），12-4=8（非平方），12-9=3（非平方）→ 不行
  - 化简：12 ÷ 4 = 3，3 % 8 ≠ 7 → 不是 4
  - 故返回 3 ✅

______________________________________________________________________

## ✅ 答案有效性证明

- **DP 正确性**：基于最优子结构，`dp[i]` 依赖于更小的子问题，且覆盖所有可能的平方数选择。
- **BFS 正确性**：首次到达 0 时路径最短，符合 BFS 性质。
- **数学法正确性**：由**拉格朗日四平方和定理**和**勒让德三平方定理**严格保证，已被数论证明。

______________________________________________________________________

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 动态规划 | $O(n \\sqrt{n})$ | $O(n)$ | 对每个 `i` 枚举最多 $\\sqrt{i}$ 个平方数 |
| BFS | 最坏 $O(n \\sqrt{n})$，平均更快 | $O(n)$ | 实际中剪枝效果好，常优于 DP |
| 数学法 | $O(\\sqrt{n})$ | $O(1)$ | 只需检查平方数和模运算，最优 |

> 💡 在 LeetCode 实测中，数学法通常最快（\<1ms），BFS 次之，DP 最慢但最通用。

______________________________________________________________________

## 📌 问题总结

- 本题是**经典动态规划**与**数论结合**的典范。
- 三种解法体现了不同思维层次：
  - **DP**：通用、直观，适合初学者；
  - **BFS**：图论视角，天然求最短步数；
  - **数学法**：利用深层数学性质，极致优化。
- 推荐掌握 DP 和 BFS 思路，数学法作为拓展了解。
- 类似题目：[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)（完全平方数即“硬币面额”）。
