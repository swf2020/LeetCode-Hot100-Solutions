# 297. 二叉树的序列化与反序列化

## 🔗 [题目链接](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree?envType=problem-list-v2&envId=2cktkvj)

## 📌 题目描述

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示**: 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，也可以采用其他的方法解决这个问题。

**说明**: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。

## 📌 示例说明

### 示例 1：

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

### 示例 2：

```
输入：root = []
输出：[]
```

### 示例 3：

```
输入：root = [1]
输出：[1]
```

### 示例 4：

```
输入：root = [1,2]
输出：[1,2]
```

## 💡 解题思路

### 方法一：层序遍历（BFS）✅

这是最直观的方法，按照 LeetCode 官方的序列化格式进行处理。

**序列化过程：**

1. 使用队列进行层序遍历
1. 对于每个节点，如果存在则添加其值到结果，否则添加 "null"
1. 注意要保留叶子节点的 null 子节点，以保证反序列化的正确性

**反序列化过程：**

1. 将字符串按逗号分割成数组
1. 第一个元素作为根节点
1. 使用队列维护待处理的父节点
1. 每次从数组中取出两个元素作为当前父节点的左右子节点
1. 如果子节点不为 null，则将其加入队列继续处理

### 方法二：前序遍历（DFS）✅

**序列化过程：**

1. 使用递归进行前序遍历
1. 对于空节点，返回特殊标记（如 "#"）
1. 对于非空节点，返回 "值,左子树序列,右子树序列"

**反序列化过程：**

1. 将字符串分割成列表
1. 使用全局索引或传引用的方式，按前序顺序重建树
1. 遇到 "#" 返回 null，否则创建新节点并递归构建左右子树

### 方法三：后序遍历（DFS）✅

原理类似前序遍历，只是遍历顺序不同。

### 方法四：中序遍历 ❌

**不能使用中序遍历！** 因为仅凭中序遍历无法唯一确定一棵二叉树，需要配合其他遍历序列。

## 💻 代码实现

=== "Java"

```java
import java.util.*;

// Definition for a binary tree node.
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class Codec {
    
    // 方法一：层序遍历（BFS）
    
    // 序列化
    public String serialize(TreeNode root) {
        if (root == null) return "[]";
        
        StringBuilder sb = new StringBuilder();
        sb.append("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if (node != null) {
                sb.append(node.val).append(",");
                queue.offer(node.left);
                queue.offer(node.right);
            } else {
                sb.append("null,");
            }
        }
        
        // 移除末尾多余的 null 和逗号
        while (sb.length() > 1 && (sb.charAt(sb.length() - 2) == 'l' || 
               sb.charAt(sb.length() - 2) == ',')) {
            if (sb.charAt(sb.length() - 2) == 'l') {
                sb.delete(sb.length() - 5, sb.length());
                break;
            } else {
                sb.deleteCharAt(sb.length() - 1);
            }
        }
        
        // 更简单的方法：直接处理字符串
        String result = sb.toString();
        result = result.substring(0, result.length() - 1); // 移除最后一个逗号
        // 移除末尾的 null
        while (result.endsWith("null")) {
            result = result.substring(0, result.lastIndexOf("null"));
            if (result.endsWith(",")) {
                result = result.substring(0, result.length() - 1);
            }
        }
        return result + "]";
    }
    
    // 反序列化
    public TreeNode deserialize(String data) {
        if (data.equals("[]")) return null;
        
        // 提取数字部分
        String[] vals = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        
        int i = 1;
        while (!queue.isEmpty() && i < vals.length) {
            TreeNode node = queue.poll();
            
            // 处理左子节点
            if (!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.offer(node.left);
            }
            i++;
            
            // 处理右子节点
            if (i < vals.length && !vals[i].equalEquals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.offer(node.right);
            }
            i++;
        }
        
        return root;
    }
    
    // 方法二：前序遍历（DFS）- 推荐方法
    public String serialize2(TreeNode root) {
        StringBuilder sb = new StringBuilder();
        serializeHelper(root, sb);
        return sb.toString();
    }
    
    private void serializeHelper(TreeNode node, StringBuilder sb) {
        if (node == null) {
            sb.append("#,");
            return;
        }
        sb.append(node.val).append(",");
        serializeHelper(node.left, sb);
        serializeHelper(node.right, sb);
    }
    
    public TreeNode deserialize2(String data) {
        String[] vals = data.split(",");
        Queue<String> queue = new LinkedList<>(Arrays.asList(vals));
        return deserializeHelper(queue);
    }
    
    private TreeNode deserializeHelper(Queue<String> queue) {
        String val = queue.poll();
        if (val.equals("#")) {
            return null;
        }
        TreeNode node = new TreeNode(Integer.parseInt(val));
        node.left = deserializeHelper(queue);
        node.right = deserializeHelper(queue);
        return node;
    }
}
```

```go
package main

import (
    "strconv"
    "strings"
)

// Definition for a binary tree node.
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

type Codec struct{}

func Constructor() Codec {
    return Codec{}
}

// 方法一：层序遍历（BFS）
func (this *Codec) serialize(root *TreeNode) string {
    if root == nil {
        return "[]"
    }
    
    var sb strings.Builder
    sb.WriteString("[")
    queue := []*TreeNode{root}
    
    for len(queue) > 0 {
        node := queue[0]
        queue = queue[1:]
        
        if node != nil {
            sb.WriteString(strconv.Itoa(node.Val))
            sb.WriteString(",")
            queue = append(queue, node.Left)
            queue = append(queue, node.Right)
        } else {
            sb.WriteString("null,")
        }
    }
    
    // 移除末尾的逗号和多余的 null
    result := sb.String()
    result = result[:len(result)-1] // 移除最后一个逗号
    
    // 移除末尾的 null
    for strings.HasSuffix(result, "null") {
        result = result[:len(result)-4]
        if strings.HasSuffix(result, ",") {
            result = result[:len(result)-1]
        }
    }
    
    return result + "]"
}

func (this *Codec) deserialize(data string) *TreeNode {
    if data == "[]" {
        return nil
    }
    
    // 提取数值
    vals := strings.Split(data[1:len(data)-1], ",")
    if len(vals) == 0 || vals[0] == "" {
        return nil
    }
    
    val, _ := strconv.Atoi(vals[0])
    root := &TreeNode{Val: val}
    queue := []*TreeNode{root}
    
    i := 1
    for len(queue) > 0 && i < len(vals) {
        node := queue[0]
        queue = queue[1:]
        
        // 左子节点
        if vals[i] != "null" {
            val, _ := strconv.Atoi(vals[i])
            node.Left = &TreeNode{Val: val}
            queue = append(queue, node.Left)
        }
        i++
        
        // 右子节点
        if i < len(vals) && vals[i] != "null" {
            val, _ := strconv.Atoi(vals[i])
            node.Right = &TreeNode{Val: val}
            queue = append(queue, node.Right)
        }
        i++
    }
    
    return root
}

// 方法二：前序遍历（DFS）- 推荐方法
func (this *Codec) serialize2(root *TreeNode) string {
    var sb strings.Builder
    this.serializeHelper(root, &sb)
    return sb.String()
}

func (this *Codec) serializeHelper(node *TreeNode, sb *strings.Builder) {
    if node == nil {
        sb.WriteString("#,")
        return
    }
    sb.WriteString(strconv.Itoa(node.Val))
    sb.WriteString(",")
    this.serializeHelper(node.Left, sb)
    this.serializeHelper(node.Right, sb)
}

func (this *Codec) deserialize2(data string) *TreeNode {
    if data == "" {
        return nil
    }
    
    vals := strings.Split(data, ",")
    // 移除最后一个空字符串（因为最后有个逗号）
    if len(vals) > 0 && vals[len(vals)-1] == "" {
        vals = vals[:len(vals)-1]
    }
    
    index := 0
    return this.deserializeHelper(vals, &index)
}

func (this *Codec) deserializeHelper(vals []string, index *int) *TreeNode {
    if *index >= len(vals) {
        return nil
    }
    
    val := vals[*index]
    *index++
    
    if val == "#" {
        return nil
    }
    
    num, _ := strconv.Atoi(val)
    node := &TreeNode{Val: num}
    node.Left = this.deserializeHelper(vals, index)
    node.Right = this.deserializeHelper(vals, index)
    
    return node
}
```

## 🎯 示例演示

让我们用示例 `[1,2,3,null,null,4,5]` 来演示：

### 层序遍历方法：

- **序列化过程**：

  - 队列：[1] → 输出 "1,"
  - 队列：[2,3] → 输出 "2,3,"
  - 队列：[null,null,4,5] → 输出 "null,null,4,5,"
  - 最终结果："[1,2,3,null,null,4,5]"

- **反序列化过程**：

  - 根节点：1
  - 1 的左右子节点：2, 3
  - 2 的左右子节点：null, null
  - 3 的左右子节点：4, 5

### 前序遍历方法：

- **序列化**：`"1,2,#,#,3,4,#,#,5,#,#,"`
- **反序列化**：按前序顺序递归构建

## ✅ 答案有效性证明

### 正确性证明：

1. **层序遍历方法**：

   - 序列化时保留了完整的层次信息，包括 null 节点
   - 反序列化时严格按照层序重建，父子关系一一对应
   - 由于我们保留了所有必要的 null 信息，可以唯一确定树结构

1. **前序遍历方法**：

   - 前序遍历 + null 标记可以唯一确定二叉树
   - 递归过程中，每个节点都被正确放置在对应位置
   - 使用队列或索引确保了遍历顺序的一致性

### 边界情况验证：

- 空树：返回 "[]" 或 "#,"，能正确反序列化
- 单节点：正确处理
- 完全不平衡树：能正确处理链式结构

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 优缺点 |
|------|------------|------------|--------|
| **层序遍历(BFS)** | O(n) | O(n) | ✅ 符合LeetCode格式<br>❌ 字符串处理较复杂 |
| **前序遍历(DFS)** | O(n) | O(n) | ✅ 实现简洁<br>✅ 递归自然<br>❌ 格式与LeetCode不同 |

**详细分析：**

- **时间复杂度**：O(n)，每个节点访问一次
- **空间复杂度**：O(n)，队列/递归栈空间 + 结果字符串空间
- **实际性能**：前序遍历通常更快，因为避免了复杂的字符串后处理

## 📝 问题总结

### 关键要点：

1. **序列化格式选择**：

   - 如果需要兼容 LeetCode 格式，使用层序遍历
   - 如果追求简洁实现，使用前序遍历

1. **null 处理**：

   - 必须正确处理 null 节点，否则无法唯一确定树结构
   - 层序遍历中要注意末尾 null 的清理

1. **实现技巧**：

   - BFS 使用队列管理节点
   - DFS 使用递归天然保持遍历顺序
   - 字符串分割和解析要小心边界情况

### 推荐方案：

对于面试场景，**推荐使用前序遍历方法**，因为：

- 代码更简洁易懂
- 递归思路清晰
- 不需要复杂的字符串后处理
- 同样满足题目要求（不要求特定格式）
