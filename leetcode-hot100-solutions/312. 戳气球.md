
##  问题简介

[LeetCode 312. 戳气球](https://leetcode.cn/problems/burst-balloons?envType=problem-list-v2&envId=2cktkvj)

### 题目描述

有 `n` 个气球，编号为 `0` 到 `n - 1`，每个气球上都标有一个数字，这些数字存在数组 `nums` 中。

现在要求你戳破所有的气球。戳破第 `i` 个气球，你可以获得 `nums[i - 1] * nums[i] * nums[i + 1]` 枚硬币。这里的 `i - 1` 和 `i + 1` 代表和 `i` 相邻的两个气球的序号。如果 `i - 1` 或 `i + 1` 超出了数组的边界，那么就当它是一个数字为 `1` 的气球。

求所能获得硬币的最大数量。

### 示例说明

**示例 1：**

```
输入：nums = [3,1,5,8]
输出：167
解释：
nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []
coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167
```

**示例 2：**

```
输入：nums = [1,5]
输出：10
```

## ❌|✅|💡|📌 解题思路

### 方法一：动态规划（区间DP）✅

这是一个经典的区间动态规划问题。关键在于思考顺序：**不是考虑先戳哪个气球，而是考虑最后戳哪个气球**。

#### 思路步骤：

1. **预处理数组**：在原数组前后各添加一个值为1的元素，这样可以简化边界处理。

   - 原数组：`[3,1,5,8]`
   - 处理后：`[1,3,1,5,8,1]`

1. **定义状态**：

   - `dp[i][j]` 表示戳破开区间 `(i, j)` 内所有气球能获得的最大硬币数
   - 注意是开区间，即不包含 `i` 和 `j` 位置的气球

1. **状态转移方程**：

   - 对于区间 `(i, j)`，我们枚举最后一个被戳破的气球 `k`（其中 `i < k < j`）
   - 当 `k` 是最后一个被戳破时，此时 `i` 和 `j` 位置的气球还在（因为是开区间）
   - 所以戳破 `k` 获得的硬币数为：`nums[i] * nums[k] * nums[j]`
   - 加上左右两个子区间的最大值：`dp[i][k] + dp[k][j]`
   - 状态转移方程：`dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])`

1. **初始化**：

   - 所有 `dp[i][j]` 初始化为 0
   - 当 `j <= i + 1` 时，区间内没有气球，`dp[i][j] = 0`

1. **计算顺序**：

   - 按照区间长度从小到大计算
   - 区间长度从 2 开始（因为开区间，长度为2表示中间有0个气球）

1. **最终答案**：

   - `dp[0][n+1]`，其中 `n` 是原数组长度

### 方法二：记忆化搜索（递归 + 缓存）✅

这是动态规划的递归版本，思路相同但实现方式不同。

1. 定义递归函数 `dfs(i, j)` 表示戳破开区间 `(i, j)` 内所有气球的最大硬币数
1. 使用记忆化数组避免重复计算
1. 递归边界：当 `j <= i + 1` 时返回 0
1. 递归关系：枚举最后戳破的气球 `k`，计算 `dfs(i, k) + dfs(k, j) + nums[i] * nums[k] * nums[j]`

### 方法三：贪心算法 ❌

贪心策略（比如每次都戳能获得最多硬币的气球）是错误的，因为当前的选择会影响后续的选择，具有后效性。

## ❌|✅|💡|📌 代码实现

```java
// Java 实现 - 动态规划
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        // 预处理：在数组前后添加1
        int[] arr = new int[n + 2];
        arr[0] = 1;
        arr[n + 1] = 1;
        for (int i = 0; i < n; i++) {
            arr[i + 1] = nums[i];
        }
        
        // dp[i][j] 表示戳破开区间 (i, j) 内所有气球的最大硬币数
        int[][] dp = new int[n + 2][n + 2];
        
        // 按区间长度从小到大计算
        for (int len = 2; len <= n + 2; len++) {
            for (int i = 0; i + len <= n + 2; i++) {
                int j = i + len;
                // 枚举最后戳破的气球 k
                for (int k = i + 1; k < j; k++) {
                    dp[i][j] = Math.max(dp[i][j], 
                        dp[i][k] + dp[k][j] + arr[i] * arr[k] * arr[j]);
                }
            }
        }
        
        return dp[0][n + 1];
    }
}

// Java 实现 - 记忆化搜索
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[] arr = new int[n + 2];
        arr[0] = 1;
        arr[n + 1] = 1;
        for (int i = 0; i < n; i++) {
            arr[i + 1] = nums[i];
        }
        
        Integer[][] memo = new Integer[n + 2][n + 2];
        return dfs(0, n + 1, arr, memo);
    }
    
    private int dfs(int i, int j, int[] arr, Integer[][] memo) {
        if (j <= i + 1) {
            return 0;
        }
        if (memo[i][j] != null) {
            return memo[i][j];
        }
        
        int res = 0;
        for (int k = i + 1; k < j; k++) {
            res = Math.max(res, 
                dfs(i, k, arr, memo) + dfs(k, j, arr, memo) + arr[i] * arr[k] * arr[j]);
        }
        memo[i][j] = res;
        return res;
    }
}
```

```go
// Go 实现 - 动态规划
func maxCoins(nums []int) int {
    n := len(nums)
    // 预处理：在数组前后添加1
    arr := make([]int, n+2)
    arr[0] = 1
    arr[n+1] = 1
    for i := 0; i < n; i++ {
        arr[i+1] = nums[i]
    }
    
    // dp[i][j] 表示戳破开区间 (i, j) 内所有气球的最大硬币数
    dp := make([][]int, n+2)
    for i := range dp {
        dp[i] = make([]int, n+2)
    }
    
    // 按区间长度从小到大计算
    for length := 2; length <= n+2; length++ {
        for i := 0; i+length <= n+2; i++ {
            j := i + length
            // 枚举最后戳破的气球 k
            for k := i+1; k < j; k++ {
                dp[i][j] = max(dp[i][j], 
                    dp[i][k] + dp[k][j] + arr[i]*arr[k]*arr[j])
            }
        }
    }
    
    return dp[0][n+1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

// Go 实现 - 记忆化搜索
func maxCoins(nums []int) int {
    n := len(nums)
    arr := make([]int, n+2)
    arr[0] = 1
    arr[n+1] = 1
    for i := 0; i < n; i++ {
        arr[i+1] = nums[i]
    }
    
    memo := make([][]*int, n+2)
    for i := range memo {
        memo[i] = make([]*int, n+2)
    }
    
    return dfs(0, n+1, arr, memo)
}

func dfs(i, j int, arr []int, memo [][]*int) int {
    if j <= i+1 {
        return 0
    }
    if memo[i][j] != nil {
        return *memo[i][j]
    }
    
    res := 0
    for k := i+1; k < j; k++ {
        res = max(res, 
            dfs(i, k, arr, memo) + dfs(k, j, arr, memo) + arr[i]*arr[k]*arr[j])
    }
    memo[i][j] = &res
    return res
}
```

## ❌|✅|💡|📌 示例演示

以 `nums = [3,1,5,8]` 为例：

1. **预处理**：`arr = [1,3,1,5,8,1]`
2. **初始化**：`dp` 数组全部为 0
3. **计算过程**：
   - 区间长度为 2：所有 `dp[i][i+2] = arr[i] * arr[i+1] * arr[i+2]`
     - `dp[0][2] = 1*3*1 = 3`
     - `dp[1][3] = 3*1*5 = 15`
     - `dp[2][4] = 1*5*8 = 40`
     - `dp[3][5] = 5*8*1 = 40`
   - 区间长度为 3：
     - `dp[0][3] = max(dp[0][1]+dp[1][3]+1*3*5, dp[0][2]+dp[2][3]+1*1*5) = max(0+15+15, 3+0+5) = 30`
     - ...（继续计算其他区间）
   - 最终 `dp[0][5] = 167`

## ❌|✅|💡|📌 答案有效性证明

### 正确性证明：

1. **最优子结构**：戳破区间 `(i,j)` 内所有气球的最优解，可以通过选择最后一个戳破的气球 `k`，将问题分解为戳破 `(i,k)` 和 `(k,j)` 两个子问题的最优解。

2. **重叠子问题**：不同的选择路径可能会产生相同的子区间问题，动态规划通过表格存储避免重复计算。

3. **边界处理正确**：通过在原数组前后添加 1，确保了边界情况的正确处理，开区间的定义使得状态转移方程简洁明了。

4. **穷举完整性**：对于每个区间 `(i,j)`，我们枚举了所有可能的最后戳破位置 `k`，确保不会遗漏最优解。

## ❌|✅|💡|📌 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 |
|------|------------|------------|
| 动态规划 | O(n³) | O(n²) |
| 记忆化搜索 | O(n³) | O(n²) |

- **时间复杂度**：三层循环，外层是区间长度 O(n)，中层是起始位置 O(n)，内层是分割点 O(n)，总计 O(n³)
- **空间复杂度**：需要 O(n²) 的二维数组存储状态

## ❌|✅|💡|📌 问题总结

### 关键洞察 💡

1. **逆向思维**：不要考虑先戳哪个，而要考虑最后戳哪个。这是解决此类问题的关键突破点。

2. **区间DP的经典应用**：这类"移除元素获得收益，且收益依赖于相邻元素"的问题，通常适合用区间DP解决。

3. **开区间的优势**：使用开区间 `(i,j)` 而不是闭区间 `[i,j]`，使得边界处理更加自然，状态转移方程更简洁。

### 解题模板 📌

对于类似的区间DP问题，可以遵循以下模板：
1. 预处理数组（如添加边界元素）
2. 定义 `dp[i][j]` 为区间 `(i,j)` 的最优解
3. 按区间长度从小到大计算
4. 枚举分割点，结合左右子区间的最优解

### 易错点提醒 ⚠️

- **边界处理**：忘记在数组前后添加 1 会导致边界情况处理复杂
- **区间定义**：混淆开区间和闭区间的定义会导致状态转移错误
- **计算顺序**：必须按照区间长度从小到大计算，确保子问题已经求解
