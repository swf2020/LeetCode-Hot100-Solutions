# 问题简介

[LeetCode 337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 `root`。

除了 `root` 之外，每栋房子有且只有一个“父”房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。如果 **两个直接相连的房子在同一天晚上被打劫**，房屋将自动报警。

给定二叉树的 `root`。返回 **在不触动警报的情况下**，小偷能够盗取的最高金额。

______________________________________________________________________

## 示例说明

### 示例 1：

```
输入: root = [3,2,3,null,3,null,1]
输出: 7 
解释: 小偷一晚可以盗取的最高金额 3 + 3 + 1 = 7
```

树结构可视化：

```
     3
    / \
   2   3
    \   \ 
     3   1
```

✅ 最优方案：选择根节点（3）、右子树的右子节点（1）和左子树的右子节点（3），总和为 7。

### 示例 2：

```
输入: root = [3,4,5,1,3,null,1]
输出: 9
解释: 小偷一晚可以盗取的最高金额 4 + 5 = 9
```

树结构可视化：

```
     3
    / \
   4   5
  / \   \ 
 1   3   1
```

✅ 最优方案：选择第二层的 4 和 5，总和为 9。

______________________________________________________________________

# 解题思路

📌 **核心限制**：不能同时打劫父子节点。

这是一个典型的**树形动态规划**（Tree DP）问题。我们需要对每个节点做出决策：**偷 or 不偷**，并基于子树的结果进行状态转移。

______________________________________________________________________

## ✅ 方法一：记忆化递归（带缓存）

### 思路步骤：

1. 对于任意节点 `node`，有两种选择：
   - **偷当前节点**：则不能偷其左右子节点，收益 = `node.val + rob(node.left.left) + rob(node.left.right) + rob(node.right.left) + rob(node.right.right)`
   - **不偷当前节点**：则可以自由选择是否偷左右子节点，收益 = `rob(node.left) + rob(node.right)`
1. 取两者最大值。
1. 但直接递归会导致大量重复计算（如 `rob(node.left)` 被多次调用），因此使用 **哈希表缓存** 已计算过的节点结果。

### 缺点：

- 代码简洁，但时间复杂度较高（虽有缓存，但状态划分不够精细）。

______________________________________________________________________

## ✅ 方法二：树形 DP（后序遍历 + 状态压缩）【推荐】

### 💡 关键洞察：

对每个节点，我们维护一个长度为 2 的数组 `res`：

- `res[0]`：**不偷当前节点**时，子树能获得的最大金额。
- `res[1]`：**偷当前节点**时，子树能获得的最大金额。

### 状态转移方程：

设当前节点为 `node`，左右子节点返回的状态分别为 `left = [l0, l1]`，`right = [r0, r1]`。

- **不偷当前节点**：左右子节点可偷可不偷 →\
  `res[0] = max(l0, l1) + max(r0, r1)`
- **偷当前节点**：左右子节点都不能偷 →\
  `res[1] = node.val + l0 + r0`

### 优势：

- 每个节点只遍历一次，无重复计算。
- 时间复杂度最优。

______________________________________________________________________

# 代码实现

```java
// 方法二：树形 DP（推荐）
class Solution {
    public int rob(TreeNode root) {
        int[] res = dfs(root);
        return Math.max(res[0], res[1]);
    }


    // 返回 [不偷当前节点的最大值, 偷当前节点的最大值]
    private int[] dfs(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0};
        }
        int[] left = dfs(node.left);
        int[] right = dfs(node.right);
    
        int notRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        int rob = node.val + left[0] + right[0];
    
        return new int[]{notRob, rob};
    }
}
```

// 方法一：记忆化递归（备选）
```java
class SolutionMemo {
    private Map\<TreeNode, Integer> memo = new HashMap\<>();
    public int rob(TreeNode root) {
        if (root == null) return 0;
        if (memo.containsKey(root)) {
            return memo.get(root);
        }
    
        // 偷当前节点
        int doRob = root.val;
        if (root.left != null) {
            doRob += rob(root.left.left) + rob(root.left.right);
        }
        if (root.right != null) {
            doRob += rob(root.right.left) + rob(root.right.right);
        }
    
        // 不偷当前节点
        int notRob = rob(root.left) + rob(root.right);
    
        int res = Math.max(doRob, notRob);
        memo.put(root, res);
        return res;
    }
}
```

// 方法二：树形 DP（推荐）
```go
func rob(root *TreeNode) int {
    res := dfs(root)
    return max(res[0], res[1])
}

// 返回 [不偷当前节点的最大值, 偷当前节点的最大值]
func dfs(node \*TreeNode) []int {
    if node == nil {
    return []int{0, 0}
    }
    left := dfs(node.Left)
    right := dfs(node.Right)
    
    
    notRob := max(left[0], left[1]) + max(right[0], right[1])
    rob := node.Val + left[0] + right[0]
    
    return []int{notRob, rob}
}
```

// 方法一：记忆化递归（备选）
```go
var memo map[\*TreeNode]int

func robMemo(root \*TreeNode) int {
    memo = make(map[\*TreeNode]int)
    return helper(root)
}

func helper(node \*TreeNode) int {
    if node == nil {
        return 0
    }
    if val, ok := memo[node]; ok {
        return val
    }   
    // 偷当前节点
    doRob := node.Val
    if node.Left != nil {
        doRob += helper(node.Left.Left) + helper(node.Left.Right)
    }
    if node.Right != nil {
        doRob += helper(node.Right.Left) + helper(node.Right.Right)
    }
    
    // 不偷当前节点
    notRob := helper(node.Left) + helper(node.Right)
    
    res := max(doRob, notRob)
    memo[node] = res
    return res
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

```

> 💡 **注意**：Go 中方法一需注意 map 的 key 不能是函数局部变量（因指针可能复用），但在 LeetCode 环境中通常安全。更严谨的做法是使用全局 map 或传入指针。

______________________________________________________________________

# 示例演示

以示例 1 为例：`root = [3,2,3,null,3,null,1]`

后序遍历过程：

1. 节点 `3`（叶）→ `[0, 3]`
1. 节点 `1`（叶）→ `[0, 1]`
1. 节点 `2`：
   - left = null → `[0,0]`
   - right = `[0,3]`
   - notRob = max(0,0) + max(0,3) = 0 + 3 = 3
   - rob = 2 + 0 + 0 = 2
   - → `[3, 2]`
1. 节点 `3`（右子）：
   - left = null, right = `[0,1]`
   - notRob = 0 + 1 = 1
   - rob = 3 + 0 + 0 = 3
   - → `[1, 3]`
1. 根节点 `3`：
   - left = `[3,2]`, right = `[1,3]`
   - notRob = max(3,2) + max(1,3) = 3 + 3 = 6
   - rob = 3 + 3 + 1 = 7
   - → `[6, 7]`
1. 最终结果 = max(6, 7) = **7** ✅

______________________________________________________________________

# 答案有效性证明

📌 **归纳法证明**：

- **基础情况**：叶子节点，返回 `[0, val]`，显然正确。
- **归纳假设**：对所有深度小于 `d` 的子树，`dfs` 返回的 `[notRob, rob]` 是正确的。
- **归纳步骤**：对深度为 `d` 的节点 `node`：
  - 若不偷 `node`，则左右子树各自可独立选择最优（偷或不偷），即 `max(left[0], left[1]) + max(right[0], right[1])`。
  - 若偷 `node`，则左右子节点必须不偷，即 `node.val + left[0] + right[0]`。
  - 二者取最大，覆盖所有合法方案，且无遗漏。

✅ 因此，算法正确。

______________________________________________________________________

# 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| ❌ 记忆化递归 | $O(n)$ | $O(n)$ | 每个节点计算一次，但递归栈 + 哈希表 |
| ✅ 树形 DP | $O(n)$ | $O(h)$ | `h` 为树高，仅递归栈空间，无额外存储 |

> 💡 虽然时间复杂度同为 $O(n)$，但树形 DP 常数更小，且空间更优（无需哈希表）。

______________________________________________________________________

# 问题总结

- 🔑 **核心思想**：树形动态规划，通过后序遍历自底向上合并子问题解。
- 🧠 **状态设计**：对每个节点维护“偷”与“不偷”两种状态，避免非法组合。
- ⚡ **优化关键**：避免重复计算，状态转移清晰。
- 📌 **适用场景**：树上相邻节点互斥的选择问题（如最大独立集）。

> ✅ 掌握此题，即可举一反三解决类似“树上不能选相邻节点”的最优化问题。
