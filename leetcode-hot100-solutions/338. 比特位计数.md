# 338. 比特位计数

[LeetCode 中文网站链接](https://leetcode.cn/problems/counting-bits?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给你一个整数 `n`，对于 `0 <= i <= n` 中的每个 `i`，计算其二进制表示中 `1` 的个数，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

______________________________________________________________________

## 示例说明

✅ **示例 1：**

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

✅ **示例 2：**

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
```

______________________________________________________________________

## 解题思路

### 💡 方法一：暴力法（逐个计算）

对每个数字 `i`（从 0 到 n），使用位运算统计其二进制中 1 的个数。

- 使用 `i & (i - 1)` 清除最低位的 1，直到 `i == 0`。
- 或者使用内置函数如 `Integer.bitCount(i)`（Java）或 `bits.OnesCount(uint(i))`（Go）。

**缺点**：时间复杂度较高，未利用已计算结果。

______________________________________________________________________

### ✅ 方法二：动态规划（最优解）

观察规律，发现：

- 偶数 `i` 的二进制中 1 的个数等于 `i / 2` 的个数（因为右移一位，末尾是 0）。
- 奇数 `i` 的二进制中 1 的个数等于 `i / 2` 的个数 + 1（因为末尾是 1）。

即：

```text
dp[i] = dp[i >> 1] + (i & 1)
```

或者等价地：

```text
dp[i] = dp[i // 2] + (i % 2)
```

📌 **状态转移方程**：

```
ans[0] = 0
ans[i] = ans[i >> 1] + (i & 1)
```

该方法利用了子问题的解，避免重复计算，效率高。

______________________________________________________________________

### 🔍 其他动态规划视角（可选）

还可以基于最高有效位（Most Significant Bit）来推导：

- 设 `x` 是小于等于 `i` 的最大 2 的幂（如 i=5，x=4）。
- 则 `ans[i] = ans[i - x] + 1`。

但实现稍复杂，不如上述方法简洁。

______________________________________________________________________

## 代码实现

```java
// Java 实现：动态规划
class Solution {
    public int[] countBits(int n) {
        int[] ans = new int[n + 1];
        for (int i = 1; i <= n; i++) {
            ans[i] = ans[i >> 1] + (i & 1);
        }
        return ans;
    }
}
```

```go
// Go 实现：动态规划
func countBits(n int) []int {
    ans := make([]int, n+1)
    for i := 1; i <= n; i++ {
        ans[i] = ans[i>>1] + (i & 1)
    }
    return ans
}
```

> 💡 注：以上代码均采用 **方法二（动态规划）**，简洁高效。

______________________________________________________________________

## 示例演示

以 `n = 5` 为例：

| i | 二进制 | i >> 1 | ans[i >> 1] | i & 1 | ans[i] |
|---|--------|--------|-------------|-------|--------|
| 0 | 000 | - | - | - | 0 |
| 1 | 001 | 0 | 0 | 1 | 1 |
| 2 | 010 | 1 | 1 | 0 | 1 |
| 3 | 011 | 1 | 1 | 1 | 2 |
| 4 | 100 | 2 | 1 | 0 | 1 |
| 5 | 101 | 2 | 1 | 1 | 2 |

✅ 输出：`[0,1,1,2,1,2]`，与预期一致。

______________________________________________________________________

## 答案有效性证明

我们通过数学归纳法证明动态规划公式的正确性：

- **基础情况**：`i = 0`，`ans[0] = 0`，正确。
- **归纳假设**：假设对所有 `k < i`，`ans[k]` 正确。
- **归纳步骤**：
  - 若 `i` 为偶数，则其二进制形式为 `...0`，去掉末尾 0 相当于 `i/2`，故 `popcount(i) = popcount(i/2)`。
  - 若 `i` 为奇数，则其二进制形式为 `...1`，去掉末尾 1 后为 `i/2`（整除），故 `popcount(i) = popcount(i/2) + 1`。
  - 而 `(i & 1)` 恰好为 0（偶）或 1（奇），因此公式成立。

由归纳法，对所有 `0 ≤ i ≤ n`，`ans[i]` 正确。

______________________________________________________________________

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 是否最优 |
|------------|------------|------------|----------|
| 暴力法 | O(n log n) | O(1) | ❌ |
| 动态规划 | **O(n)** | **O(1)**（不计输出） | ✅ |

- **时间**：每个 `i` 只需 O(1) 计算。
- **空间**：仅需返回数组，无额外空间。

______________________________________________________________________

## 问题总结

📌 **关键洞察**：\
二进制数的结构具有递归性质——**右移一位相当于除以 2**，而最低位决定是否多一个 1。

✅ **推荐解法**：\
使用动态规划 `ans[i] = ans[i >> 1] + (i & 1)`，代码简洁、效率高、易于理解。

💡 **延伸思考**：\
此题展示了位运算与动态规划的完美结合，类似思想可用于其他位操作问题（如汉明距离、格雷码等）。掌握 `i & (i-1)`、`i & 1`、`i >> 1` 等技巧对解决位运算问题至关重要。
