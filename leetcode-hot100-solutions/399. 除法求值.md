## é—®é¢˜ç®€ä»‹

[LeetCode 399. é™¤æ³•æ±‚å€¼](https://leetcode.cn/problems/evaluate-division?envType=problem-list-v2&envId=2cktkvj)

### é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªå˜é‡å¯¹æ•°ç»„ `equations` å’Œä¸€ä¸ªå®æ•°å€¼æ•°ç»„ `values` ä½œä¸ºå·²çŸ¥æ¡ä»¶ï¼Œå…¶ä¸­ `equations[i] = [Ai, Bi]` å’Œ `values[i]` è¡¨ç¤ºç­‰å¼ `Ai / Bi = values[i]`ã€‚å¦æœ‰ä¸€äº›ä»¥æ•°ç»„ `queries` è¡¨ç¤ºçš„é—®é¢˜ï¼Œå…¶ä¸­ `queries[j] = [Cj, Dj]` è¡¨ç¤ºç¬¬ `j` ä¸ªé—®é¢˜ï¼Œè¯·ä½ æ ¹æ®å·²çŸ¥æ¡ä»¶æ‰¾å‡º `Cj / Dj = ?` çš„ç»“æœä½œä¸ºç­”æ¡ˆã€‚

è¿”å›æ‰€æœ‰é—®é¢˜çš„ç­”æ¡ˆã€‚å¦‚æœå­˜åœ¨æŸä¸ªæ— æ³•ç¡®å®šçš„ç­”æ¡ˆï¼Œåˆ™ç”¨ `-1.0` æ›¿ä»£è¿™ä¸ªç­”æ¡ˆã€‚å¦‚æœé—®é¢˜ä¸­å‡ºç°äº†ç»™å®šçš„å·²çŸ¥æ¡ä»¶ä¸­æ²¡æœ‰å‡ºç°çš„å­—ç¬¦ä¸²ï¼Œä¹Ÿéœ€è¦ç”¨ `-1.0` æ›¿ä»£è¿™ä¸ªç­”æ¡ˆã€‚

æ³¨æ„ï¼šè¾“å…¥æ€»æ˜¯æœ‰æ•ˆçš„ã€‚ä½ å¯ä»¥å‡è®¾é™¤æ³•è¿ç®—ä¸­ä¸ä¼šå‡ºç°é™¤æ•°ä¸º 0 çš„æƒ…å†µï¼Œä¸”ä¸å­˜åœ¨ä»»ä½•çŸ›ç›¾çš„ç»“æœã€‚

______________________________________________________________________

## ç¤ºä¾‹è¯´æ˜

âœ… **ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥ï¼š
equations = [["a","b"],["b","c"]], 
values = [2.0,3.0], 
queries = [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]

è¾“å‡ºï¼š[6.00000,0.50000,-1.00000,1.00000,-1.00000]

è§£é‡Šï¼š
æ¡ä»¶ï¼ša / b = 2.0, b / c = 3.0
é—®é¢˜ï¼ša / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ?
ç»“æœï¼š[6.0, 0.5, -1.0, 1.0, -1.0 ]
```

âœ… **ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥ï¼š
equations = [["a","b"],["b","c"],["bc","cd"]], 
values = [1.5,2.5,5.0], 
queries = [["a","c"],["c","b"],["bc","cd"],["cd","bc"]]

è¾“å‡ºï¼š[3.75000,0.40000,5.00000,0.20000]
```

âœ… **ç¤ºä¾‹ 3ï¼š**

```
è¾“å…¥ï¼š
equations = [["a","b"]], 
values = [0.5], 
queries = [["a","b"],["b","a"],["a","c"],["x","y"]]

è¾“å‡ºï¼š[0.50000,2.00000,-1.00000,-1.00000]
```

______________________________________________________________________

## è§£é¢˜æ€è·¯

è¿™ä¸ªé—®é¢˜æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª**å›¾è®ºé—®é¢˜**ï¼šæ¯ä¸ªå˜é‡æ˜¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæ¯ä¸ªç­‰å¼ `A/B = v` è¡¨ç¤ºä» A åˆ° B æœ‰ä¸€æ¡æƒé‡ä¸º `v` çš„æœ‰å‘è¾¹ï¼ŒåŒæ—¶ä» B åˆ° A æœ‰ä¸€æ¡æƒé‡ä¸º `1/v` çš„æœ‰å‘è¾¹ã€‚

æˆ‘ä»¬éœ€è¦å›ç­”æŸ¥è¯¢ `C/D = ?`ï¼Œè¿™ç›¸å½“äºåœ¨å›¾ä¸­æ‰¾åˆ°ä» C åˆ° D çš„è·¯å¾„ï¼Œå¹¶å°†è·¯å¾„ä¸Šæ‰€æœ‰è¾¹çš„æƒé‡ç›¸ä¹˜ã€‚

### æ–¹æ³•ä¸€ï¼šDFSï¼ˆæ·±åº¦ä¼˜å…ˆæœç´¢ï¼‰

ğŸ“Œ **æ ¸å¿ƒæ€æƒ³ï¼š**

1. æ„å»ºé‚»æ¥è¡¨è¡¨ç¤ºçš„å›¾
1. å¯¹æ¯ä¸ªæŸ¥è¯¢ï¼Œä»èµ·ç‚¹å¼€å§‹ DFS æœç´¢ç»ˆç‚¹
1. åœ¨æœç´¢è¿‡ç¨‹ä¸­è®°å½•å½“å‰è·¯å¾„çš„ç´¯ç§¯ä¹˜ç§¯
1. å¦‚æœæ‰¾åˆ°ç»ˆç‚¹ï¼Œè¿”å›ç´¯ç§¯ä¹˜ç§¯ï¼›å¦åˆ™è¿”å› -1.0

### æ–¹æ³•äºŒï¼šBFSï¼ˆå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰

ğŸ“Œ **æ ¸å¿ƒæ€æƒ³ï¼š**

1. åŒæ ·æ„å»ºé‚»æ¥è¡¨
1. å¯¹æ¯ä¸ªæŸ¥è¯¢ï¼Œä½¿ç”¨ BFS ä»èµ·ç‚¹å¼€å§‹æœç´¢
1. ä½¿ç”¨é˜Ÿåˆ—å­˜å‚¨ `(å½“å‰èŠ‚ç‚¹, å½“å‰ç´¯ç§¯ä¹˜ç§¯)`
1. æ‰¾åˆ°ç»ˆç‚¹æ—¶è¿”å›å¯¹åº”çš„ä¹˜ç§¯

### æ–¹æ³•ä¸‰ï¼šå¹¶æŸ¥é›†ï¼ˆUnion-Findï¼‰+ è·¯å¾„å‹ç¼©

ğŸ“Œ **æ ¸å¿ƒæ€æƒ³ï¼š**

1. ç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹åˆ°å…¶æ ¹èŠ‚ç‚¹çš„æƒé‡æ¯”å€¼
1. åœ¨ union æ“ä½œæ—¶æ›´æ–°æƒé‡å…³ç³»
1. æŸ¥è¯¢æ—¶é€šè¿‡å…±åŒæ ¹èŠ‚ç‚¹è®¡ç®—æ¯”å€¼

### æ–¹æ³•å››ï¼šFloyd-Warshall ç®—æ³•

ğŸ“Œ **æ ¸å¿ƒæ€æƒ³ï¼š**

1. å°†æ‰€æœ‰å˜é‡æ˜ å°„ä¸ºæ•°å­—ç´¢å¼•
1. åˆå§‹åŒ–è·ç¦»çŸ©é˜µï¼Œ`dist[i][j]` è¡¨ç¤º `var_i / var_j`
1. ä½¿ç”¨ Floyd-Warshall ç®—æ³•è®¡ç®—æ‰€æœ‰ç‚¹å¯¹ä¹‹é—´çš„æ¯”å€¼

ğŸ’¡ **é€‰æ‹©å»ºè®®ï¼š**

- **DFS/BFS**ï¼šå®ç°ç®€å•ï¼Œé€‚åˆç¨€ç–å›¾
- **å¹¶æŸ¥é›†**ï¼šæ•ˆç‡é«˜ï¼Œé€‚åˆå¤šæ¬¡æŸ¥è¯¢
- **Floyd-Warshall**ï¼šé€‚åˆç¨ å¯†å›¾å’Œéœ€è¦é¢„å¤„ç†æ‰€æœ‰æŸ¥è¯¢çš„æƒ…å†µ

______________________________________________________________________

## ä»£ç å®ç°

```java
import java.util.*;

public class Solution {
    // æ–¹æ³•ä¸€ï¼šDFS
    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
        // æ„å»ºå›¾
        Map<String, Map<String, Double>> graph = new HashMap<>();
        
        for (int i = 0; i < equations.size(); i++) {
            String u = equations.get(i).get(0);
            String v = equations.get(i).get(1);
            double value = values[i];
            
            graph.putIfAbsent(u, new HashMap<>());
            graph.putIfAbsent(v, new HashMap<>());
            
            graph.get(u).put(v, value);
            graph.get(v).put(u, 1.0 / value);
        }
        
        double[] result = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            String start = queries.get(i).get(0);
            String end = queries.get(i).get(1);
            
            if (!graph.containsKey(start) || !graph.containsKey(end)) {
                result[i] = -1.0;
            } else if (start.equals(end)) {
                result[i] = 1.0;
            } else {
                Set<String> visited = new HashSet<>();
                result[i] = dfs(graph, start, end, visited);
            }
        }
        
        return result;
    }
    
    private double dfs(Map<String, Map<String, Double>> graph, String curr, String target, Set<String> visited) {
        if (curr.equals(target)) {
            return 1.0;
        }
        
        visited.add(curr);
        
        for (Map.Entry<String, Double> neighbor : graph.get(curr).entrySet()) {
            String next = neighbor.getKey();
            double weight = neighbor.getValue();
            
            if (!visited.contains(next)) {
                double result = dfs(graph, next, target, visited);
                if (result != -1.0) {
                    return weight * result;
                }
            }
        }
        
        visited.remove(curr);
        return -1.0;
    }
    
    // æ–¹æ³•äºŒï¼šBFS
    public double[] calcEquationBFS(List<List<String>> equations, double[] values, List<List<String>> queries) {
        Map<String, Map<String, Double>> graph = new HashMap<>();
        
        for (int i = 0; i < equations.size(); i++) {
            String u = equations.get(i).get(0);
            String v = equations.get(i).get(1);
            double value = values[i];
            
            graph.putIfAbsent(u, new HashMap<>());
            graph.putIfAbsent(v, new HashMap<>());
            
            graph.get(u).put(v, value);
            graph.get(v).put(u, 1.0 / value);
        }
        
        double[] result = new double[queries.size()];
        for (int i = 0; i < queries.size(); i++) {
            String start = queries.get(i).get(0);
            String end = queries.get(i).get(1);
            
            if (!graph.containsKey(start) || !graph.containsKey(end)) {
                result[i] = -1.0;
            } else if (start.equals(end)) {
                result[i] = 1.0;
            } else {
                result[i] = bfs(graph, start, end);
            }
        }
        
        return result;
    }
    
    private double bfs(Map<String, Map<String, Double>> graph, String start, String end) {
        Queue<Pair<String, Double>> queue = new LinkedList<>();
        Set<String> visited = new HashSet<>();
        
        queue.offer(new Pair<>(start, 1.0));
        visited.add(start);
        
        while (!queue.isEmpty()) {
            Pair<String, Double> current = queue.poll();
            String node = current.getKey();
            double product = current.getValue();
            
            if (node.equals(end)) {
                return product;
            }
            
            for (Map.Entry<String, Double> neighbor : graph.get(node).entrySet()) {
                String next = neighbor.getKey();
                double weight = neighbor.getValue();
                
                if (!visited.contains(next)) {
                    visited.add(next);
                    queue.offer(new Pair<>(next, product * weight));
                }
            }
        }
        
        return -1.0;
    }
    
    // è¾…åŠ©ç±»ç”¨äºBFS
    static class Pair<K, V> {
        private K key;
        private V value;
        
        public Pair(K key, V value) {
            this.key = key;
            this.value = value;
        }
        
        public K getKey() { return key; }
        public V getValue() { return value; }
    }
}
```

```go
package main

import "fmt"

// æ–¹æ³•ä¸€ï¼šDFS
func calcEquation(equations [][]string, values []float64, queries [][]string) []float64 {
    // æ„å»ºå›¾
    graph := make(map[string]map[string]float64)
    
    for i, eq := range equations {
        u, v := eq[0], eq[1]
        value := values[i]
        
        if _, exists := graph[u]; !exists {
            graph[u] = make(map[string]float64)
        }
        if _, exists := graph[v]; !exists {
            graph[v] = make(map[string]float64)
        }
        
        graph[u][v] = value
        graph[v][u] = 1.0 / value
    }
    
    result := make([]float64, len(queries))
    for i, query := range queries {
        start, end := query[0], query[1]
        
        if _, exists1 := graph[start]; !exists1 {
            result[i] = -1.0
        } else if _, exists2 := graph[end]; !exists2 {
            result[i] = -1.0
        } else if start == end {
            result[i] = 1.0
        } else {
            visited := make(map[string]bool)
            result[i] = dfs(graph, start, end, visited)
        }
    }
    
    return result
}

func dfs(graph map[string]map[string]float64, curr, target string, visited map[string]bool) float64 {
    if curr == target {
        return 1.0
    }
    
    visited[curr] = true
    
    for next, weight := range graph[curr] {
        if !visited[next] {
            result := dfs(graph, next, target, visited)
            if result != -1.0 {
                return weight * result
            }
        }
    }
    
    delete(visited, curr)
    return -1.0
}

// æ–¹æ³•äºŒï¼šBFS
func calcEquationBFS(equations [][]string, values []float64, queries [][]string) []float64 {
    graph := make(map[string]map[string]float64)
    
    for i, eq := range equations {
        u, v := eq[0], eq[1]
        value := values[i]
        
        if _, exists := graph[u]; !exists {
            graph[u] = make(map[string]float64)
        }
        if _, exists := graph[v]; !exists {
            graph[v] = make(map[string]float64)
        }
        
        graph[u][v] = value
        graph[v][u] = 1.0 / value
    }
    
    result := make([]float64, len(queries))
    for i, query := range queries {
        start, end := query[0], query[1]
        
        if _, exists1 := graph[start]; !exists1 {
            result[i] = -1.0
        } else if _, exists2 := graph[end]; !exists2 {
            result[i] = -1.0
        } else if start == end {
            result[i] = 1.0
        } else {
            result[i] = bfs(graph, start, end)
        }
    }
    
    return result
}

type pair struct {
    node    string
    product float64
}

func bfs(graph map[string]map[string]float64, start, end string) float64 {
    queue := []pair{{start, 1.0}}
    visited := make(map[string]bool)
    visited[start] = true
    
    for len(queue) > 0 {
        current := queue[0]
        queue = queue[1:]
        node := current.node
        product := current.product
        
        if node == end {
            return product
        }
        
        for next, weight := range graph[node] {
            if !visited[next] {
                visited[next] = true
                queue = append(queue, pair{next, product * weight})
            }
        }
    }
    
    return -1.0
}

// æµ‹è¯•å‡½æ•°
func main() {
    equations := [][]string{{"a", "b"}, {"b", "c"}}
    values := []float64{2.0, 3.0}
    queries := [][]string{{"a", "c"}, {"b", "a"}, {"a", "e"}, {"a", "a"}, {"x", "x"}}
    
    result := calcEquation(equations, values, queries)
    fmt.Println(result) // [6 -0.5 -1 1 -1]
}
```

______________________________________________________________________

## ç¤ºä¾‹æ¼”ç¤º

è®©æˆ‘ä»¬ä»¥ç¤ºä¾‹ 1 ä¸ºä¾‹æ¼”ç¤ºç®—æ³•æ‰§è¡Œè¿‡ç¨‹ï¼š

```
equations = [["a","b"],["b","c"]]
values = [2.0,3.0]
queries = [["a","c"]]
```

### å›¾æ„å»ºè¿‡ç¨‹ï¼š

- `a -> b: 2.0`, `b -> a: 0.5`
- `b -> c: 3.0`, `c -> b: 1/3`

### æŸ¥è¯¢ `a/c` çš„ DFS è¿‡ç¨‹ï¼š

1. ä» `a` å¼€å§‹ï¼Œè®¿é—®é‚»å±… `b`ï¼ˆæƒé‡ 2.0ï¼‰
1. ä» `b` å¼€å§‹ï¼Œè®¿é—®é‚»å±… `c`ï¼ˆæƒé‡ 3.0ï¼‰
1. åˆ°è¾¾ç›®æ ‡ `c`ï¼Œè¿”å› `2.0 * 3.0 = 6.0`

### å¯è§†åŒ–å›¾ç»“æ„ï¼š

```
    2.0      3.0
a ------> b ------> c
    <------    <------
     0.5       1/3
```

______________________________________________________________________

## ç­”æ¡ˆæœ‰æ•ˆæ€§è¯æ˜

âœ… **æ­£ç¡®æ€§åˆ†æï¼š**

1. **å›¾æ„å»ºæ­£ç¡®æ€§**ï¼šæ¯ä¸ªç­‰å¼ `A/B = v` è¢«æ­£ç¡®è½¬æ¢ä¸ºåŒå‘è¾¹ï¼Œæƒé‡åˆ†åˆ«ä¸º `v` å’Œ `1/v`

1. **è·¯å¾„ä¹˜ç§¯æ­£ç¡®æ€§**ï¼šå¦‚æœå­˜åœ¨è·¯å¾„ `A â†’ Xâ‚ â†’ Xâ‚‚ â†’ ... â†’ Xâ‚™ â†’ B`ï¼Œåˆ™ï¼š

   ```
   A/B = (A/Xâ‚) Ã— (Xâ‚/Xâ‚‚) Ã— ... Ã— (Xâ‚™/B)
   ```

   è¿™æ­£æ˜¯æˆ‘ä»¬åœ¨ DFS/BFS ä¸­ç´¯ç§¯è®¡ç®—çš„å€¼

1. **è¾¹ç•Œæƒ…å†µå¤„ç†**ï¼š

   - ç›¸åŒå˜é‡ï¼š`A/A = 1.0`
   - ä¸å­˜åœ¨çš„å˜é‡ï¼šè¿”å› `-1.0`
   - æ— æ³•åˆ°è¾¾ï¼šè¿”å› `-1.0`

1. **æ— çŸ›ç›¾ä¿è¯**ï¼šé¢˜ç›®ä¿è¯ä¸å­˜åœ¨çŸ›ç›¾ç»“æœï¼Œæ‰€ä»¥ä»»æ„ä¸¤ç‚¹é—´çš„æ‰€æœ‰è·¯å¾„éƒ½ä¼šå¾—åˆ°ç›¸åŒçš„æ¯”å€¼

âŒ **æ½œåœ¨é—®é¢˜åŠè§£å†³æ–¹æ¡ˆï¼š**

- **æµ®ç‚¹ç²¾åº¦é—®é¢˜**ï¼šåœ¨å®é™…åº”ç”¨ä¸­å¯èƒ½éœ€è¦è€ƒè™‘ç²¾åº¦è¯¯å·®ï¼Œä½† LeetCode æµ‹è¯•ç”¨ä¾‹é€šå¸¸ä¸æ¶‰åŠæ­¤é—®é¢˜
- **å¾ªç¯æ£€æµ‹**ï¼šé€šè¿‡ `visited` é›†åˆé¿å…æ— é™å¾ªç¯

______________________________________________________________________

## å¤æ‚åº¦åˆ†æ

| æ–¹æ³• | æ—¶é—´å¤æ‚åº¦ | ç©ºé—´å¤æ‚åº¦ | é€‚ç”¨åœºæ™¯ |
|------|------------|------------|----------|
| **DFS** | O(Q Ã— (V + E)) | O(V + E) | æŸ¥è¯¢æ¬¡æ•°å°‘ï¼Œå›¾è¾ƒç¨€ç– |
| **BFS** | O(Q Ã— (V + E)) | O(V + E) | åŒä¸Šï¼Œä½†å¯èƒ½æ›´å¿«æ‰¾åˆ°çŸ­è·¯å¾„ |
| **å¹¶æŸ¥é›†** | O((E + Q) Ã— Î±(V)) | O(V) | æŸ¥è¯¢æ¬¡æ•°å¤šï¼Œéœ€è¦é«˜æ•ˆå¤„ç† |
| **Floyd-Warshall** | O(VÂ³ + Q) | O(VÂ²) | å˜é‡æ•°é‡å°‘ï¼ŒæŸ¥è¯¢æ¬¡æ•°æå¤š |

å…¶ä¸­ï¼š

- `V` = å˜é‡æ•°é‡ï¼ˆé¡¶ç‚¹æ•°ï¼‰
- `E` = ç­‰å¼æ•°é‡ï¼ˆè¾¹æ•°ï¼‰
- `Q` = æŸ¥è¯¢æ•°é‡
- `Î±` = é˜¿å…‹æ›¼å‡½æ•°çš„åå‡½æ•°ï¼ˆè¿‘ä¹å¸¸æ•°ï¼‰

ğŸ’¡ **å®é™…é€‰æ‹©å»ºè®®ï¼š**

- å¯¹äº LeetCode çš„æµ‹è¯•ç”¨ä¾‹ï¼Œ**DFS å®ç°æœ€ç®€å•ä¸”æ•ˆç‡è¶³å¤Ÿ**
- å¦‚æœæŸ¥è¯¢æ¬¡æ•°éå¸¸å¤šï¼ˆæ¯”å¦‚ 10âµ+ï¼‰ï¼Œè€ƒè™‘å¹¶æŸ¥é›†
- å¦‚æœå˜é‡æ€»æ•°å¾ˆå°‘ï¼ˆæ¯”å¦‚ < 100ï¼‰ï¼ŒFloyd-Warshall ä¹Ÿæ˜¯ä¸é”™çš„é€‰æ‹©

______________________________________________________________________

## é—®é¢˜æ€»ç»“

ğŸ“Œ **æ ¸å¿ƒè¦ç‚¹å›é¡¾ï¼š**

1. **é—®é¢˜è½¬åŒ–**ï¼šå°†é™¤æ³•ç­‰å¼è½¬åŒ–ä¸ºå¸¦æƒæœ‰å‘å›¾
1. **å›¾éå†**ï¼šé€šè¿‡ DFS/BFS å¯»æ‰¾è·¯å¾„å¹¶è®¡ç®—æƒé‡ä¹˜ç§¯
1. **è¾¹ç•Œå¤„ç†**ï¼šæ­£ç¡®å¤„ç†ä¸å­˜åœ¨å˜é‡ã€ç›¸åŒå˜é‡ç­‰æƒ…å†µ

âœ… **å…³é”®æŠ€å·§ï¼š**

- åŒå‘å»ºå›¾ï¼š`A/B = v` â‡’ `Aâ†’B: v`, `Bâ†’A: 1/v`
- è·¯å¾„ä¹˜ç§¯ï¼šè·¯å¾„ä¸Šæ‰€æœ‰è¾¹æƒé‡çš„ä¹˜ç§¯å³ä¸ºæ‰€æ±‚æ¯”å€¼
- è®¿é—®æ ‡è®°ï¼šé¿å…åœ¨å›¾ä¸­æ— é™å¾ªç¯

ğŸ’¡ **æ‰©å±•æ€è€ƒï¼š**

- å¦‚æœå…è®¸çŸ›ç›¾æ•°æ®ï¼Œå¦‚ä½•æ£€æµ‹çŸ›ç›¾ï¼Ÿ
- å¦‚æœéœ€è¦æ”¯æŒåŠ¨æ€æ·»åŠ ç­‰å¼ï¼Œå“ªç§æ•°æ®ç»“æ„æ›´åˆé€‚ï¼Ÿ
- å¦‚ä½•å¤„ç†æµ®ç‚¹ç²¾åº¦é—®é¢˜ï¼Ÿ

è¿™ä¸ªé—®é¢˜å¾ˆå¥½åœ°å±•ç¤ºäº†**å›¾è®ºåœ¨å®é™…é—®é¢˜ä¸­çš„åº”ç”¨**ï¼Œå°†çœ‹ä¼¼æ•°å­¦çš„é—®é¢˜è½¬åŒ–ä¸ºå›¾çš„è·¯å¾„æŸ¥æ‰¾é—®é¢˜ï¼Œæ˜¯ç®—æ³•æ€ç»´çš„ç»å…¸ä½“ç°ã€‚
