# 问题简介

[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，并返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

______________________________________________________________________

## 示例说明

✅ **示例 1：**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

✅ **示例 2：**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

______________________________________________________________________

## 解题思路

### 💡 方法一：滑动窗口 + 字符频次数组（推荐）

这是最经典、高效的解法。

#### 步骤详解：

1. **预处理**：

   - 若 `s` 长度小于 `p`，直接返回空列表。
   - 创建两个长度为 26 的数组 `need` 和 `window`，分别记录 `p` 中每个字符的频次，以及当前窗口中各字符的频次。

1. **初始化窗口**：

   - 先将 `p` 的字符频次填入 `need`。
   - 将 `s` 的前 `len(p)` 个字符填入 `window`。

1. **滑动窗口**：

   - 比较 `need` 与 `window` 是否相等，若相等，则当前窗口起始位置是一个答案。
   - 然后窗口向右滑动一位：移除左边字符，加入右边新字符。
   - 重复比较，直到窗口滑到 `s` 末尾。

1. **优化比较**：

   - 可以不用每次全数组比较（O(26)），而是维护一个 `matchCount` 记录有多少个字符的频次匹配，从而实现 O(1) 判断。

> ✅ 本解法采用直接数组比较（简洁清晰），也可进一步优化为计数器方式。

______________________________________________________________________

### 💡 方法二：滑动窗口 + HashMap（通用但稍慢）

适用于字符集不限于小写字母的情况（如 Unicode）。

- 用 `HashMap<Character, Integer>` 替代数组。
- 逻辑同方法一，但哈希表操作常数较大。

> 📌 本题限定小写字母，因此方法一更优。

______________________________________________________________________

### ❌ 不推荐方法：暴力枚举 + 排序

- 枚举 `s` 中每个长度为 `len(p)` 的子串。
- 对每个子串和 `p` 排序后比较是否相等。
- 时间复杂度 O(n * m log m)，其中 m = len(p)，效率低。

______________________________________________________________________

## 代码实现

<div class="code-tabs">

```java:Java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int sLen = s.length(), pLen = p.length();
        if (sLen < pLen) return res;

        // 频次数组
        int[] need = new int[26];
        int[] window = new int[26];

        // 初始化 p 的频次
        for (char c : p.toCharArray()) {
            need[c - 'a']++;
        }

        // 初始化第一个窗口
        for (int i = 0; i < pLen; i++) {
            window[s.charAt(i) - 'a']++;
        }

        // 检查第一个窗口
        if (Arrays.equals(need, window)) {
            res.add(0);
        }

        // 滑动窗口：从 pLen 开始
        for (int i = pLen; i < sLen; i++) {
            // 加入新字符
            window[s.charAt(i) - 'a']++;
            // 移除旧字符
            window[s.charAt(i - pLen) - 'a']--;

            // 检查当前窗口
            if (Arrays.equals(need, window)) {
                res.add(i - pLen + 1);
            }
        }

        return res;
    }
}
```

```go:Go
func findAnagrams(s string, p string) []int {
    var res []int
    sLen, pLen := len(s), len(p)
    if sLen < pLen {
        return res
    }

    need := make([]int, 26)
    window := make([]int, 26)

    // 初始化 p 的频次
    for _, c := range p {
        need[c-'a']++
    }

    // 初始化第一个窗口
    for i := 0; i < pLen; i++ {
        window[s[i]-'a']++
    }

    // 检查第一个窗口
    if equal(need, window) {
        res = append(res, 0)
    }

    // 滑动窗口
    for i := pLen; i < sLen; i++ {
        window[s[i]-'a']++
        window[s[i-pLen]-'a']--

        if equal(need, window) {
            res = append(res, i-pLen+1)
        }
    }

    return res
}

// 辅助函数：比较两个切片是否相等
func equal(a, b []int) bool {
    for i := 0; i < 26; i++ {
        if a[i] != b[i] {
            return false
        }
    }
    return true
}
```

</div>

______________________________________________________________________

## 示例演示

以 `s = "cbaebabacd"`, `p = "abc"` 为例：

| 步骤 | 窗口位置 | 窗口内容 | window 数组（简写） | 是否匹配 |
|------|----------|----------|---------------------|--------|
| 初始 | [0,2] | "cba" | [1,1,1,0,...] | ✅ 是 → 添加 0 |
| 滑1 | [1,3] | "bae" | [0,1,1,0,1,...] | ❌ 否 |
| 滑2 | [2,4] | "aeb" | [1,1,0,0,1,...] | ❌ 否 |
| ... | ... | ... | ... | ... |
| 滑6 | [6,8] | "bac" | [1,1,1,0,...] | ✅ 是 → 添加 6 |

最终结果：`[0, 6]`

______________________________________________________________________

## 答案有效性证明

✅ **正确性**：

- 异位词 ⇨ 字符种类和数量完全相同 ⇨ 频次数组相等。
- 滑动窗口遍历了 `s` 中所有长度为 `len(p)` 的子串，无遗漏。
- 每次窗口移动只更新两个字符的频次，保证状态正确。

✅ **边界处理**：

- `s` 长度小于 `p` 时直接返回空，避免越界。
- 窗口从 `0` 到 `sLen - pLen` 共 `sLen - pLen + 1` 个位置，全部覆盖。

______________________________________________________________________

## 复杂度分析

| 项目 | 复杂度 |
|------|--------|
| ⏱️ 时间复杂度 | O(n × 26) = **O(n)**，其中 n = len(s)。每次 `Arrays.equals` 最多比较 26 个元素。 |
| 💾 空间复杂度 | **O(1)**，仅使用两个固定长度（26）的数组，不随输入规模增长。 |

> 📌 若使用优化版（维护 matchCount），时间可进一步优化为严格 O(n)，但常数差异不大。

______________________________________________________________________

## 问题总结

📌 **关键点回顾**：

- 异位词的本质是 **字符频次相同**。
- 滑动窗口是处理“固定长度子串”问题的利器。
- 小写字母场景下，**数组代替哈希表** 更高效、简洁。

💡 **扩展思考**：

- 若字符集扩大（如包含大写、数字），可改用 `HashMap` 或扩大数组大小。
- 类似题目：LeetCode 567（字符串的排列）、76（最小覆盖子串）。

✅ **一句话总结**：\
**用滑动窗口维护字符频次，通过数组比较快速判断异位词，高效且优雅。**
