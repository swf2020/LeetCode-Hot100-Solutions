# 问题简介

[48. 旋转图像 - LeetCode](https://leetcode.cn/problems/rotate-image?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定一个 `n × n` 的二维矩阵 `matrix` 表示一个图像。请你将图像 **顺时针旋转 90 度**。

你必须在 **原地** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

______________________________________________________________________

# 示例说明

✅ **示例 1：**

```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[[7,4,1],[8,5,2],[9,6,3]]
```

✅ **示例 2：**

```
输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]
输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]
```

✅ **示例 3：**

```
输入：matrix = [[1]]
输出：[[1]]
```

✅ **示例 4：**

```
输入：matrix = [[1,2],[3,4]]
输出：[[3,1],[4,2]]
```

📌 **约束条件：**

- `n == matrix.length == matrix[i].length`
- `1 <= n <= 20`
- `-1000 <= matrix[i][j] <= 1000`

______________________________________________________________________

# 解题思路

## 💡 方法一：两次翻转（推荐）

> **核心思想**：顺时针旋转 90° 等价于 **先沿主对角线翻转（转置）**，**再沿垂直中轴线左右翻转**。

### 步骤详解：

1. **转置矩阵（沿主对角线翻转）**\
   将 `matrix[i][j]` 与 `matrix[j][i]` 交换（仅遍历上三角或下三角，避免重复交换）。

1. **左右翻转每一行**\
   对每一行，将第 `j` 列与第 `n-1-j` 列交换（`j` 从 `0` 到 `n/2 - 1`）。

✅ **优点**：逻辑清晰、代码简洁、原地操作、时间复杂度最优。

______________________________________________________________________

## 💡 方法二：直接旋转（四点轮换）

> **核心思想**：将矩阵划分为若干“环”，每个环上的元素按组（每组4个）进行轮换。

### 步骤详解：

对于 `n×n` 矩阵：

- 外层循环控制“圈数”：共 `n/2` 圈（整数除法）。
- 内层循环控制每圈中需要旋转的起始位置：每圈有 `n - 1 - 2*layer` 个元素需要处理。
- 对于每个位置 `(layer, i)`，其对应的四个位置为：
  - `(layer, i)`
  - `(i, n-1-layer)`
  - `(n-1-layer, n-1-i)`
  - `(n-1-i, layer)`

然后将这四个位置的值顺时针轮换。

✅ **优点**：直观体现“旋转”过程。\
❌ **缺点**：索引计算稍复杂，容易出错。

______________________________________________________________________

## 💡 方法三：使用辅助矩阵（不符合题意，仅作对比）

> 创建新矩阵 `newMatrix`，令 `newMatrix[j][n-1-i] = matrix[i][j]`，再拷贝回原矩阵。

❌ **不满足题目“原地旋转”要求**，但有助于理解旋转规律。

______________________________________________________________________

# 代码实现

```java
// Java 实现
class Solution {
    // 方法一：两次翻转
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        
        // Step 1: 转置（沿主对角线翻转）
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
        
        // Step 2: 左右翻转每一行
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n / 2; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[i][n - 1 - j];
                matrix[i][n - 1 - j] = temp;
            }
        }
    }

    // 方法二：四点轮换（可选）
    public void rotate_v2(int[][] matrix) {
        int n = matrix.length;
        for (int layer = 0; layer < n / 2; layer++) {
            int last = n - 1 - layer;
            for (int i = layer; i < last; i++) {
                int offset = i - layer;
                int top = matrix[layer][i]; // 保存顶部

                // 左 → 上
                matrix[layer][i] = matrix[last - offset][layer];
                // 下 → 左
                matrix[last - offset][layer] = matrix[last][last - offset];
                // 右 → 下
                matrix[last][last - offset] = matrix[i][last];
                // 上 → 右
                matrix[i][last] = top;
            }
        }
    }
}
````

```go
// Go 实现
func rotate(matrix [][]int) {
    n := len(matrix)
    
    // Step 1: 转置（沿主对角线翻转）
    for i := 0; i < n; i++ {
        for j := i + 1; j < n; j++ {
            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        }
    }
    
    // Step 2: 左右翻转每一行
    for i := 0; i < n; i++ {
        for j := 0; j < n/2; j++ {
            matrix[i][j], matrix[i][n-1-j] = matrix[i][n-1-j], matrix[i][j]
        }
    }
}

// 方法二：四点轮换（可选）
func rotate_v2(matrix [][]int) {
    n := len(matrix)
    for layer := 0; layer < n/2; layer++ {
        last := n - 1 - layer
        for i := layer; i < last; i++ {
            offset := i - layer
            top := matrix[layer][i]
            matrix[layer][i] = matrix[last-offset][layer]
            matrix[last-offset][layer] = matrix[last][last-offset]
            matrix[last][last-offset] = matrix[i][last]
            matrix[i][last] = top
        }
    }
}
```


---

# 示例演示

以 `matrix = [[1,2,3],[4,5,6],[7,8,9]]` 为例：

### 方法一步骤：

1. **转置后**：
```

\[[1,4,7],
[2,5,8],
[3,6,9]\]

```

2. **左右翻转后**：
```

\[[7,4,1],
[8,5,2],
[9,6,3]\] ✅

```

### 方法二步骤（外层一圈）：

- 旋转 `(0,0)→(0,2)→(2,2)→(2,0)→(0,0)`：1→3→9→7→1
- 旋转 `(0,1)→(1,2)→(2,1)→(1,0)→(0,1)`：2→6→8→4→2

结果一致。

---

# 答案有效性证明

我们验证旋转公式是否成立：

> 对于任意位置 `(i, j)`，顺时针旋转 90° 后的新位置为 `(j, n-1-i)`。

- **方法一**：
- 转置后：`(i, j) → (j, i)`
- 左右翻转后：`(j, i) → (j, n-1-i)` ✅

- **方法二**：
- 直接将 `(layer, i)` 的值赋给 `(i, n-1-layer)`，符合上述映射 ✅

因此两种方法均正确。

---

# 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 是否原地 |
|------|------------|------------|----------|
| 两次翻转 | $O(n^2)$ | $O(1)$ | ✅ |
| 四点轮换 | $O(n^2)$ | $O(1)$ | ✅ |
| 辅助矩阵 | $O(n^2)$ | $O(n^2)$ | ❌ |

> 📌 **说明**：所有元素恰好被访问常数次，故时间复杂度为 $O(n^2)$，空间复杂度为 $O(1)$（仅用常量额外空间）。

---

# 问题总结

✅ **关键洞察**：  
- 顺时针旋转 90° 可分解为 **转置 + 水平翻转**，这是线性代数中的经典变换组合。
- 原地操作要求我们避免额外空间，因此需利用对称性和索引映射。

✅ **推荐解法**：**两次翻转法**，因其逻辑清晰、代码简洁、不易出错。

✅ **扩展思考**：
- 逆时针旋转 90°？ → 转置 + 垂直翻转，或水平翻转 + 转置。
- 旋转 180°？ → 水平翻转 + 垂直翻转，或直接 `matrix[i][j] ↔ matrix[n-1-i][n-1-j]`。

💡 **技巧**：遇到矩阵旋转/翻转类问题，优先考虑**分解为基本对称操作**（转置、水平/垂直翻转），往往能简化实现。
