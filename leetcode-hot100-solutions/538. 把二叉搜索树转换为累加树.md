# 538. 把二叉搜索树转换为累加树

## 问题简介

[LeetCode 538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree?envType=problem-list-v2&envId=2cktkvj)

### 题目描述

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

- 节点的左子树仅包含键 **小于** 节点键的节点。
- 节点的右子树仅包含键 **大于** 节点键的节点。
- 左右子树也必须是二叉搜索树。

注意：本题和 [1038: 从二叉搜索树到更大和树](https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/) 相同。

## 示例说明

### 示例 1：

```
输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
```

### 示例 2：

```
输入：root = [0,null,1]
输出：[1,null,1]
```

### 示例 3：

```
输入：root = [1,0,2]
输出：[3,3,2]
```

### 示例 4：

```
输入：root = [3,2,4,1]
输出：[7,9,4,10]
```

## 解题思路

### 方法一：反向中序遍历（推荐）

#### 思路分析

1. **理解累加树定义**：每个节点的新值 = 原树中所有 ≥ 该节点值的节点值之和
1. **利用BST性质**：BST的中序遍历是升序序列，那么**反向中序遍历**（右→根→左）就是降序序列
1. **累加策略**：在反向中序遍历过程中，维护一个累加和 `sum`，每次访问节点时：
   - 将当前节点值加到 `sum` 中
   - 将 `sum` 赋值给当前节点的新值
1. **递归实现**：按照右子树 → 根节点 → 左子树的顺序进行递归

#### 步骤详解

1. 初始化全局变量 `sum = 0`
1. 从根节点开始进行反向中序遍历
1. 先处理右子树（更大的值）
1. 处理当前节点：`sum += node.val`，然后 `node.val = sum`
1. 再处理左子树（更小的值）

### 方法二：中序遍历 + 前缀和

#### 思路分析

1. 先进行正常的中序遍历，得到升序数组
1. 计算后缀和数组（从右到左的累加和）
1. 再次中序遍历，将对应的后缀和赋值给每个节点

这种方法需要额外的 O(n) 空间存储数组，不如方法一优雅。

### 方法三：Morris 反向中序遍历

可以使用 Morris 遍历实现 O(1) 空间复杂度的解法，但实现较为复杂，在实际面试中较少要求。

## 代码实现

```java
// Java 实现 - 反向中序遍历
class Solution {
    private int sum = 0;
    
    public TreeNode convertBST(TreeNode root) {
        if (root != null) {
            // 先遍历右子树
            convertBST(root.right);
            // 处理当前节点
            sum += root.val;
            root.val = sum;
            // 再遍历左子树
            convertBST(root.left);
        }
        return root;
    }
}

// 方法二：迭代实现
class Solution {
    public TreeNode convertBST(TreeNode root) {
        int sum = 0;
        TreeNode node = root;
        Stack<TreeNode> stack = new Stack<>();
        
        while (!stack.isEmpty() || node != null) {
            // 一直向右走到底
            while (node != null) {
                stack.push(node);
                node = node.right;
            }
            // 处理栈顶节点
            node = stack.pop();
            sum += node.val;
            node.val = sum;
            // 转向左子树
            node = node.left;
        }
        
        return root;
    }
}
```

```go
// Go 实现 - 反向中序遍历
func convertBST(root *TreeNode) *TreeNode {
    sum := 0
    var dfs func(*TreeNode)
    dfs = func(node *TreeNode) {
        if node == nil {
            return
        }
        // 先遍历右子树
        dfs(node.Right)
        // 处理当前节点
        sum += node.Val
        node.Val = sum
        // 再遍历左子树
        dfs(node.Left)
    }
    dfs(root)
    return root
}

// 方法二：迭代实现
func convertBST(root *TreeNode) *TreeNode {
    sum := 0
    node := root
    stack := []*TreeNode{}
    
    for len(stack) > 0 || node != nil {
        // 一直向右走到底
        for node != nil {
            stack = append(stack, node)
            node = node.Right
        }
        // 处理栈顶节点
        node = stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        sum += node.Val
        node.Val = sum
        // 转向左子树
        node = node.Left
    }
    
    return root
}
```


## 示例演示

以示例1为例：`[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]`

### 原始BST结构


```
    4
  /   \
 1     6
/ \   / \
0  2  5 7
    \    \
     3    8

```

### 反向中序遍历顺序
8 → 7 → 6 → 5 → 4 → 3 → 2 → 1 → 0

### 累加过程
| 访问节点 | 当前sum | 节点新值 |
|---------|---------|----------|
| 8       | 8       | 8        |
| 7       | 15      | 15       |
| 6       | 21      | 21       |
| 5       | 26      | 26       |
| 4       | 30      | 30       |
| 3       | 33      | 33       |
| 2       | 35      | 35       |
| 1       | 36      | 36       |
| 0       | 36      | 36       |

### 最终结果
```
    30
  /    \
 36     21
/ \    / \
36 35 26 15
    \     \
    33     8

```

## 答案有效性证明

### 正确性证明

1. **BST性质保证**：反向中序遍历确实按照降序访问所有节点
2. **累加正确性**：当访问节点 `node` 时，`sum` 已经包含了所有大于 `node.val` 的节点值之和
3. **包含自身**：我们将 `node.val` 加入 `sum` 后再赋值，确保了"大于或等于"的条件
4. **完整性**：遍历了所有节点，每个节点都被正确更新

### 数学归纳法验证

- **基础情况**：最大值节点（最右节点）的新值等于其原值，正确
- **归纳假设**：假设所有大于 `k` 的节点都已正确转换
- **归纳步骤**：当处理值为 `k` 的节点时，`sum` 包含了所有大于 `k` 的节点的新贡献，加上 `k` 本身，正好是所有 ≥ `k` 的值之和

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| 递归反向中序 | O(n) | O(h) | h为树的高度，最坏O(n)，平均O(log n) |
| 迭代反向中序 | O(n) | O(h) | 使用显式栈，空间复杂度相同 |
| 中序+前缀和 | O(n) | O(n) | 需要额外数组存储 |
| Morris遍历 | O(n) | O(1) | 常数空间，但修改树结构临时 |

其中 `n` 为节点数量，`h` 为树的高度。

## 问题总结

### 🔑 核心要点

1. **充分利用BST性质**：BST的中序遍历有序性是解题关键
2. **反向思维**：题目要求"大于等于"，自然想到从大到小处理
3. **累加技巧**：在遍历过程中维护累加和，避免重复计算

### 💡 解题技巧

- 遇到BST相关问题，首先考虑中序遍历
- 当需要"右侧信息"时，考虑反向中序遍历（右→根→左）
- 全局变量或引用传递可以简化递归实现

### 📌 注意事项

- 递归深度可能达到 O(n)，对于极度不平衡的树要注意栈溢出
- 迭代实现虽然代码稍长，但避免了递归的函数调用开销
- 题目保证节点值各不相同，简化了逻辑处理

这道题很好地展示了如何利用数据结构的特性来优化算法，是BST经典应用之一。
