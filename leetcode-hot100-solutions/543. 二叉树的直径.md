# 问题简介

[LeetCode 543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定一棵二叉树，你需要计算它的直径长度。二叉树的直径长度是指任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

**注意**：两结点之间的路径长度是以它们之间边的数目表示。

______________________________________________________________________

# 示例说明

📌 **示例 1：**

```
输入：root = [1,2,3,4,5]
输出：3
解释：3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
```

对应的二叉树结构如下：

```
      1
     / \
    2   3
   / \
  4   5
```

📌 **示例 2：**

```
输入：root = [1,2]
输出：1
```

______________________________________________________________________

# 解题思路

💡 **核心观察**：

- 二叉树中任意一条路径，都可以看作是某个节点作为“最高点”（即路径的转折点），其左子树向下延伸的最长路径 + 右子树向下延伸的最长路径。
- 因此，**直径 = max(左子树深度 + 右子树深度)**，遍历所有节点取最大值即可。
- 注意：直径不一定经过根节点！

✅ **解法一：DFS + 全局变量（推荐）**

1. 定义一个全局变量 `maxDiameter` 记录当前最大直径。
1. 编写一个递归函数 `depth(node)`，返回以 `node` 为根的子树的最大深度（从 node 到最远叶子的边数）。
1. 在每次递归中：
   - 计算当前节点的左子树深度 `left = depth(node.left)`
   - 计算右子树深度 `right = depth(node.right)`
   - 更新直径：`maxDiameter = max(maxDiameter, left + right)`
   - 返回当前子树深度：`return max(left, right) + 1`
1. 最终返回 `maxDiameter`

❌ **错误思路警示**：

- 不能直接用 `depth(root.left) + depth(root.right)`，因为最大直径可能出现在子树中，而非根节点。

✅ **解法二：DFS 返回 (深度, 直径) 对（无全局变量）**

- 递归函数返回两个值：当前子树的最大深度和该子树内的最大直径。
- 合并左右子树信息时，更新当前直径为 `max(leftDiameter, rightDiameter, leftDepth + rightDepth)`
- 适用于不允许使用全局变量的场景。

> 本文主要实现**解法一**，因其简洁高效。

______________________________________________________________________

# 代码实现

<div class="code-tabs">

```java:Java
class Solution {
    private int maxDiameter = 0;

    public int diameterOfBinaryTree(TreeNode root) {
        depth(root);
        return maxDiameter;
    }

    private int depth(TreeNode node) {
        if (node == null) {
            return 0;
        }
        int left = depth(node.left);
        int right = depth(node.right);
        // 更新最大直径
        maxDiameter = Math.max(maxDiameter, left + right);
        // 返回当前节点的最大深度
        return Math.max(left, right) + 1;
    }
}
```

```go:Go
func diameterOfBinaryTree(root *TreeNode) int {
    maxDiameter := 0

    var depth func(*TreeNode) int
    depth = func(node *TreeNode) int {
        if node == nil {
            return 0
        }
        left := depth(node.Left)
        right := depth(node.Right)
        // 更新最大直径
        if left + right > maxDiameter {
            maxDiameter = left + right
        }
        // 返回当前节点的最大深度
        if left > right {
            return left + 1
        }
        return right + 1
    }

    depth(root)
    return maxDiameter
}
```

</div>

______________________________________________________________________

# 示例演示

以示例 1 为例：`[1,2,3,4,5]`

递归过程（括号内为 `(深度, 当前直径)`）：

```
        1
       / \
   (2,2) (1,0)
     / \
(1,0) (1,0)
  4     5
```

- 节点 4：深度=1，直径=0
- 节点 5：深度=1，直径=0
- 节点 2：左深=1，右深=1 → 直径=2，深度=2
- 节点 3：深度=1，直径=0
- 节点 1：左深=2，右深=1 → 直径=3 → **maxDiameter = 3**

✅ 最终返回 3，正确。

______________________________________________________________________

# 答案有效性证明

📌 **数学归纳法简证**：

- **基础情况**：空树或单节点，直径为 0，算法返回 0，正确。
- **归纳假设**：对所有节点数 < n 的二叉树，算法正确。
- **归纳步骤**：对 n 个节点的树，设根为 r，左子树 L，右子树 R。
  - 由归纳假设，`depth(L)` 和 `depth(R)` 正确返回最大深度。
  - 经过 r 的最长路径为 `depth(L) + depth(R)`
  - 不经过 r 的最长路径必在 L 或 R 中，已在递归中计算并更新到 `maxDiameter`
  - 因此 `maxDiameter` 最终为全局最大值。

✅ 算法正确。

______________________________________________________________________

# 复杂度分析

| 项目 | 复杂度 | 说明 |
|------|--------|------|
| ⏱️ 时间复杂度 | $O(n)$ | 每个节点访问一次 |
| 🧠 空间复杂度 | $O(h)$ | 递归栈深度，h 为树高；最坏 $O(n)$（链状），最好 $O(\\log n)$（平衡树） |

______________________________________________________________________

# 问题总结

✅ **关键点回顾**：

- 二叉树直径 = 所有节点的（左子树深度 + 右子树深度）的最大值。
- 使用 DFS 后序遍历，在回溯过程中更新答案。
- 全局变量记录最大值，避免重复计算。

💡 **延伸思考**：

- 若题目要求返回具体路径（而不仅是长度），可额外记录路径节点。
- 此方法可推广至 N 叉树（需找最大两个子树深度之和）。

📌 **一句话总结**：**“直径藏在每个节点的左右臂展中，DFS 一探究竟。”**
