# 问题简介

[621. 任务调度器 - LeetCode](https://leetcode.cn/problems/task-scheduler?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给你一个用字符数组 `tasks` 表示的 CPU 需要执行的任务列表，其中每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一项任务，或者处于待命状态。

然而，两个 **相同种类** 的任务之间必须有长度为整数 `n` 的冷却时间，因此至少有连续 `n` 个单位时间内 CPU 在执行不同的任务，或者在待命状态。

你需要计算完成所有任务所需要的 **最短时间**。

______________________________________________________________________

# 示例说明

✅ **示例 1：**

```
输入：tasks = ["A","A","A","B","B","B"], n = 2
输出：8
解释：A -> B -> idle -> A -> B -> idle -> A -> B.
```

✅ **示例 2：**

```
输入：tasks = ["A","A","A","B","B","B"], n = 0
输出：6
解释：在这种情况下，任何顺序都是有效的，比如 A -> B -> A -> B -> A -> B。
```

✅ **示例 3：**

```
输入：tasks = ["A","A","A","A","A","A","B","C","D","E","F","G"], n = 2
输出：16
解释：一种可能的解决方案是：
A -> B -> C -> A -> D -> E -> A -> F -> G -> A -> idle -> idle -> A -> idle -> idle -> A
```

______________________________________________________________________

# 解题思路

## 💡 核心观察

- 冷却时间 `n` 意味着相同任务之间至少间隔 `n` 个其他任务或空闲。
- 最耗时的任务（出现次数最多的）决定了整体框架。
- 我们可以将任务安排想象成一个矩阵，行数由最大频次决定，列数由 `n + 1` 决定。

______________________________________________________________________

## ✅ 方法一：贪心 + 数学推导（主流解法）

### 步骤详解：

1. **统计每个任务的出现次数**。
1. **找出最大频次 `maxFreq`**。
1. **统计有多少个任务具有最大频次 `maxCount`**（例如：A 和 B 都出现了 3 次，则 `maxCount = 2`）。
1. **计算理论最小时间**：
   - 框架大小：`(maxFreq - 1) * (n + 1)` —— 前 `maxFreq - 1` 轮，每轮最多 `n+1` 个槽位。
   - 最后一轮只放 `maxCount` 个高频任务（无需冷却）。
   - 所以总时间为：`(maxFreq - 1) * (n + 1) + maxCount`
1. **但注意**：如果任务总数很多，可能不需要空闲时间（即任务本身就能填满所有槽位），此时答案就是 `tasks.length`。
1. **最终答案取两者最大值**。

📌 **公式**：

```text
ans = max( (maxFreq - 1) * (n + 1) + maxCount, tasks.length )
```

______________________________________________________________________

## ❌ 方法二：模拟（优先队列）

虽然可行，但效率较低（O(time log k)，time 可能很大），不推荐用于本题。

- 使用最大堆维护任务剩余次数。
- 每轮取最多 `n+1` 个不同任务执行。
- 将未执行完的任务暂存，本轮结束后放回堆。
- 计数总时间。

> 由于 LeetCode 数据规模较大，此方法容易超时或代码复杂，故不作为主推。

______________________________________________________________________

# 代码实现

<div class="code-tabs">

```java:Java
class Solution {
    public int leastInterval(char[] tasks, int n) {
        // 统计频次
        int[] freq = new int[26];
        for (char c : tasks) {
            freq[c - 'A']++;
        }
        
        // 找最大频次
        int maxFreq = 0;
        for (int f : freq) {
            maxFreq = Math.max(maxFreq, f);
        }
        
        // 统计有多少任务达到最大频次
        int maxCount = 0;
        for (int f : freq) {
            if (f == maxFreq) {
                maxCount++;
            }
        }
        
        // 计算理论最小时间
        int minTime = (maxFreq - 1) * (n + 1) + maxCount;
        
        // 与任务总数取最大值
        return Math.max(minTime, tasks.length);
    }
}
```

```go:Go
func leastInterval(tasks []byte, n int) int {
    freq := make([]int, 26)
    for _, task := range tasks {
        freq[task - 'A']++
    }

    maxFreq := 0
    for _, f := range freq {
        if f > maxFreq {
            maxFreq = f
        }
    }

    maxCount := 0
    for _, f := range freq {
        if f == maxFreq {
            maxCount++
        }
    }

    minTime := (maxFreq - 1) * (n + 1) + maxCount
    if minTime > len(tasks) {
        return minTime
    }
    return len(tasks)
}
```

</div>

______________________________________________________________________

# 示例演示

以 `tasks = ["A","A","A","B","B","B"], n = 2` 为例：

| 步骤 | 说明 |
|------|------|
| 1. 统计频次 | A:3, B:3 → `maxFreq = 3` |
| 2. 统计最大频次任务数 | A 和 B 都是 3 → `maxCount = 2` |
| 3. 计算框架时间 | `(3-1)*(2+1) + 2 = 2*3 + 2 = 8` |
| 4. 任务总数 | 6 |
| 5. 取最大值 | `max(8, 6) = 8` ✅ |

安排如下（X 表示空闲）：

```
A B X
A B X
A B
→ 共 8 单位时间
```

______________________________________________________________________

# 答案有效性证明

✅ **为什么公式成立？**

- 最高频任务（如 A 出现 3 次）必须至少间隔 `n`，所以最早完成时间为：
  ```
  A _ _ A _ _ A  → 长度 = (3-1)*(n+1) + 1 = 2*3 + 1 = 7
  ```
- 如果还有另一个任务 B 也出现 3 次，可与 A 并排：
  ```
  A B _ 
  A B _
  A B   → 长度 = (3-1)*3 + 2 = 8
  ```
- 若其他任务足够多（如超过 `(maxFreq-1)*(n+1)`），则无需空闲，直接顺序执行即可，时间 = `len(tasks)`。

✅ **边界情况覆盖：**

- `n = 0` → 无冷却，答案 = `len(tasks)`
- 所有任务不同 → 无冲突，答案 = `len(tasks)`
- 一个任务占绝大多数 → 空闲主导，用公式计算

______________________________________________________________________

# 复杂度分析

| 项目 | 复杂度 |
|------|--------|
| 时间复杂度 | O(m)，其中 m 是任务数量（仅需遍历一次统计 + 常数次遍历 26 字母） |
| 空间复杂度 | O(1)，仅使用固定大小（26）的频次数组 |

> ⚡ 非常高效，适合大规模数据。

______________________________________________________________________

# 问题总结

📌 **关键点回顾：**

- 冷却时间约束下，**最高频任务决定下限**。
- 使用 **数学构造法** 避免模拟，大幅提升效率。
- 最终答案是 **构造时间** 与 **任务总数** 的较大者。

💡 **技巧提炼：**

> “安排任务时，先排最频繁的，其余任务尽量填空；若填不满，就加空闲；若填得下，就不需要空闲。”

✅ **适用场景：**

- 任务调度
- 资源分配带冷却期
- 排班系统设计

此题展示了 **贪心思想 + 数学建模** 在算法优化中的强大力量。
