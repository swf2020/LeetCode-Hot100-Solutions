# 75. 颜色分类

## 📌 问题简介

[LeetCode 75. 颜色分类](https://leetcode.cn/problems/sort-colors?envType=problem-list-v2&envId=2cktkvj)

**题目描述：**

给定一个包含红色、白色和蓝色元素的数组 `nums`，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、`1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

## 📌 示例说明

**示例 1：**

```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```

**示例 2：**

```
输入：nums = [2,0,1]
输出：[0,1,2]
```

**示例 3：**

```
输入：nums = [0]
输出：[0]
```

**示例 4：**

```
输入：nums = [1]
输出：[1]
```

## 💡 解题思路

### 方法一：计数排序（两遍扫描）✅

**思路步骤：**

1. 第一遍遍历数组，统计 0、1、2 的出现次数
1. 第二遍遍历数组，按照计数结果重新填充数组

**优点：** 简单直观，容易理解\
**缺点：** 需要两次遍历

### 方法二：双指针（一次扫描）✅✅✅

**思路步骤：**

1. 使用两个指针 `left` 和 `right`，分别指向数组的开始和结束位置
1. `left` 指针用于放置 0，`right` 指针用于放置 2
1. 使用一个遍历指针 `i` 从左到右扫描数组：
   - 如果 `nums[i] == 0`，将其与 `nums[left]` 交换，`left++`，`i++`
   - 如果 `nums[i] == 2`，将其与 `nums[right]` 交换，`right--`（注意：此时 `i` 不增加，因为交换过来的元素还未处理）
   - 如果 `nums[i] == 1`，直接 `i++`

**关键点：** 当交换 2 时，不能立即增加 `i`，因为从右边交换过来的元素可能是 0 或 2，需要再次处理。

### 方法三：三指针（荷兰国旗问题）✅✅

**思路步骤：**

1. 使用三个指针：`zero`（0 的右边界）、`two`（2 的左边界）、`i`（当前遍历位置）
1. 初始化：`zero = 0`, `two = n`, `i = 0`
1. 遍历条件：`i < two`
   - 如果 `nums[i] == 0`：交换 `nums[i]` 和 `nums[zero]`，`zero++`，`i++`
   - 如果 `nums[i] == 2`：交换 `nums[i]` 和 `nums[two-1]`，`two--`（`i` 不变）
   - 如果 `nums[i] == 1`：`i++`

这实际上是方法二的另一种表述方式。

## 💻 代码实现

```java
// 方法一：计数排序
class Solution {
    public void sortColors(int[] nums) {
        int count0 = 0, count1 = 0, count2 = 0;
        
        // 统计各颜色数量
        for (int num : nums) {
            if (num == 0) count0++;
            else if (num == 1) count1++;
            else count2++;
        }
        
        // 重新填充数组
        int index = 0;
        while (count0-- > 0) nums[index++] = 0;
        while (count1-- > 0) nums[index++] = 1;
        while (count2-- > 0) nums[index++] = 2;
    }
}

// 方法二：双指针（推荐）
class Solution {
    public void sortColors(int[] nums) {
        int left = 0, right = nums.length - 1;
        int i = 0;
        
        while (i <= right) {
            if (nums[i] == 0) {
                swap(nums, i, left);
                left++;
                i++;
            } else if (nums[i] == 2) {
                swap(nums, i, right);
                right--;
                // 注意：这里不增加 i，因为交换过来的元素需要再次检查
            } else {
                i++;
            }
        }
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

```go
// 方法一：计数排序
func sortColors(nums []int) {
    count0, count1, count2 := 0, 0, 0
    
    // 统计各颜色数量
    for _, num := range nums {
        if num == 0 {
            count0++
        } else if num == 1 {
            count1++
        } else {
            count2++
        }
    }
    
    // 重新填充数组
    idx := 0
    for count0 > 0 {
        nums[idx] = 0
        idx++
        count0--
    }
    for count1 > 0 {
        nums[idx] = 1
        idx++
        count1--
    }
    for count2 > 0 {
        nums[idx] = 2
        idx++
        count2--
    }
}

// 方法二：双指针（推荐）
func sortColors(nums []int) {
    left, right := 0, len(nums)-1
    i := 0
    
    for i <= right {
        if nums[i] == 0 {
            nums[i], nums[left] = nums[left], nums[i]
            left++
            i++
        } else if nums[i] == 2 {
            nums[i], nums[right] = nums[right], nums[i]
            right--
            // 注意：这里不增加 i，因为交换过来的元素需要再次检查
        } else {
            i++
        }
    }
}
```

## 🎯 示例演示

以 `nums = [2,0,2,1,1,0]` 为例，演示双指针方法：

| 步骤 | 数组状态 | i | left | right | 操作 |
|------|----------|---|------|-------|------|
| 初始 | [2,0,2,1,1,0] | 0 | 0 | 5 | nums[0]=2，与nums[5]交换 |
| 1 | [0,0,2,1,1,2] | 0 | 0 | 4 | nums[0]=0，与nums[0]交换 |
| 2 | [0,0,2,1,1,2] | 1 | 1 | 4 | nums[1]=0，与nums[1]交换 |
| 3 | [0,0,2,1,1,2] | 2 | 2 | 4 | nums[2]=2，与nums[4]交换 |
| 4 | [0,0,1,1,2,2] | 2 | 2 | 3 | nums[2]=1，i++ |
| 5 | [0,0,1,1,2,2] | 3 | 2 | 3 | nums[3]=1，i++ |
| 结束 | [0,0,1,1,2,2] | 4 | 2 | 3 | i > right，结束 |

## ✅ 答案有效性证明

**正确性证明：**

1. **计数排序方法：**

   - 通过精确统计每种颜色的数量，然后按顺序重新填充，保证了结果的正确性

1. **双指针方法：**

   - **不变量维护：** 在任何时候，`[0, left)` 区间内都是 0，`(right, n-1]` 区间内都是 2
   - **终止条件：** 当 `i > right` 时，所有未处理的元素都已经被正确放置
   - **边界处理：** 当遇到 2 时，交换后不增加 `i`，确保新交换过来的元素也被正确处理

**为什么交换 2 后不增加 i？**

- 因为从 `right` 位置交换过来的元素可能是 0、1 或 2
- 如果是 0，需要在下一轮循环中将其移动到左边
- 如果是 2，需要继续向右交换
- 只有当确认当前元素是 1 时，才能安全地增加 `i`

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 遍历次数 |
|------|------------|------------|----------|
| 计数排序 | O(n) | O(1) | 2次 |
| 双指针 | O(n) | O(1) | 1次 |

- **时间复杂度：** 两种方法都是 O(n)，其中 n 是数组长度
- **空间复杂度：** 都是 O(1)，只使用了常数额外空间
- **实际性能：** 双指针方法通常更快，因为只需要一次遍历

## 📝 问题总结

❌ **常见错误：**

- 在双指针方法中，交换 2 后忘记处理新交换过来的元素（即错误地增加 `i`）
- 边界条件处理不当，导致数组越界

✅ **最佳实践：**

- **推荐使用双指针方法**，因为它只需要一次遍历，效率更高
- 这个问题也被称为"荷兰国旗问题"，是经典的三路快排分区问题
- 理解不变量的概念对于解决这类分区问题非常重要

💡 **扩展思考：**

- 如果有 k 种颜色（k > 3），可以使用计数排序，时间复杂度 O(n + k)
- 对于一般的三路分区问题，双指针方法是标准解法
