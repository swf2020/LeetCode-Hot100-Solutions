# 问题简介

[LeetCode 79. 单词搜索](https://leetcode.cn/problems/word-search?envType=problem-list-v2&envId=2cktkvj)

## 题目描述

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word`。如果 `word` 存在于网格中，返回 `true`；否则，返回 `false`。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

______________________________________________________________________

# 示例说明

✅ **示例 1：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

✅ **示例 2：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

❌ **示例 3：**

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

📌 **解释**：

- 在示例1中，路径为 `(0,0) → (0,1) → (1,1) → (1,2) → (2,2) → (2,1)`。
- 在示例3中，虽然前三个字母 "ABC" 可以找到，但第四个字母 "B" 无法在不重复使用单元格的情况下找到。

______________________________________________________________________

# 解题思路

💡 **核心思想：回溯（Backtracking） + 深度优先搜索（DFS）**

由于题目要求在二维网格中寻找一条路径，且不能重复使用单元格，这天然适合用 **回溯算法** 来解决。

### 步骤分解：

1. **遍历起点**：从网格中的每一个位置 `(i, j)` 尝试作为单词的起始字符。
1. **匹配首字符**：若 `board[i][j] == word[0]`，则从此处开始 DFS。
1. **DFS 回溯过程**：
   - 标记当前单元格为已访问（例如设为特殊字符如 `'#'`）。
   - 递归检查上下左右四个方向是否能继续匹配 `word` 的下一个字符。
   - 若某条路径成功匹配完整个 `word`，立即返回 `true`。
   - 若当前路径失败，**回溯**：恢复当前单元格的原始字符，尝试其他路径。
1. **终止条件**：
   - 成功：`index == word.length()`，即整个单词已匹配。
   - 失败：越界、字符不匹配、或已访问。

### 其他可能解法？

- ❌ **BFS 不适用**：因为需要维护路径状态（避免重复使用），BFS 难以高效回溯。
- ❌ **动态规划不适用**：无最优子结构，且状态依赖路径历史。
- ✅ **唯一合理解法：DFS + 回溯**

______________________________________________________________________

# 代码实现

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        if (board == null || board.length == 0 || word == null || word.isEmpty()) {
            return false;
        }
        int m = board.length, n = board[0].length;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dfs(board, word, 0, i, j)) {
                    return true;
                }
            }
        }
        return false;
    }


   private boolean dfs(char[][] board, String word, int index, int i, int j) {
       // 成功终止条件
       if (index == word.length()) {
           return true;
       }
       // 边界检查 & 字符匹配检查
       if (i < 0 || i >= board.length || j < 0 || j >= board[0].length || 
           board[i][j] != word.charAt(index)) {
           return false;
       }
   
       // 标记已访问
       char temp = board[i][j];
       board[i][j] = '#'; // 占位符
   
       // 递归四个方向
       boolean found = dfs(board, word, index + 1, i + 1, j) ||
                       dfs(board, word, index + 1, i - 1, j) ||
                       dfs(board, word, index + 1, i, j + 1) ||
                       dfs(board, word, index + 1, i, j - 1);
   
       // 回溯：恢复原字符
       board[i][j] = temp;
   
       return found;
   }
}
```

```go
// Go 实现
func exist(board [][]byte, word string) bool {
    if len(board) == 0 || len(board[0]) == 0 || word == "" {
        return false
    }
    m, n := len(board), len(board[0])

   var dfs func(index, i, j int) bool
   dfs = func(index, i, j int) bool {
       if index == len(word) {
           return true
       }
       if i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[index] {
           return false
       }
   
       // 标记已访问
       temp := board[i][j]
       board[i][j] = '#'
   
       // 递归四个方向
       found := dfs(index+1, i+1, j) ||
                dfs(index+1, i-1, j) ||
                dfs(index+1, i, j+1) ||
                dfs(index+1, i, j-1)
   
       // 回溯
       board[i][j] = temp
       return found
   }

   for i := 0; i < m; i++ {
       for j := 0; j < n; j++ {
           if dfs(0, i, j) {
               return true
           }
       }
   }
   return false
}
```

> 💡 **注意**：两种语言都采用 **原地标记 + 回溯**，空间效率高，无需额外 visited 数组。

______________________________________________________________________

# 示例演示

以 `board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]]`, `word = "ABCCED"` 为例：

1. 起点 `(0,0)` 匹配 `'A'` ✅
1. 向右到 `(0,1)` 匹配 `'B'` ✅
1. 向下到 `(1,1)` 匹配 `'C'` ❌（实际是 `'F'`）→ 错！
   - 正确路径：`(0,1)` → `(0,2)`（'C'）→ `(1,2)`（'C'）→ `(2,2)`（'E'）→ `(2,1)`（'D'）
1. 最终匹配 `"A-B-C-C-E-D"` ✅

回溯过程会自动尝试所有可能分支，直到找到有效路径或穷尽所有可能。

______________________________________________________________________

# 答案有效性证明

✅ **正确性**：

- **完备性**：遍历所有可能起点，DFS 探索所有合法路径，不会遗漏。
- **无重复使用**：通过临时修改 `board[i][j] = '#'` 确保同一路径中单元格不被重复访问。
- **回溯正确**：每次递归返回后恢复原值，不影响其他路径搜索。

✅ **边界处理**：

- 空输入、单字符、全不匹配等边界情况均被覆盖。

______________________________________________________________________

# 复杂度分析

| 项目 | 分析 |
|------|------|
| **时间复杂度** | 最坏情况：每个起点尝试所有路径，每步有 3 个方向（排除来路），深度为 `L = len(word)`，总共有 `M×N` 个起点。<br>→ **O(M × N × 3^L)** |
| **空间复杂度** | 递归栈深度最大为 `L`，无额外空间（原地标记）。<br>→ **O(L)** |

📌 **优化提示**：若 `word` 首尾字符出现频率差异大，可从较少的一端开始搜索（但本题未要求）。

______________________________________________________________________

# 问题总结

| 要点 | 说明 |
|------|------|
| ✅ **核心算法** | 回溯 + DFS |
| ✅ **关键技巧** | 原地标记（`#`）避免额外空间 |
| ✅ **适用场景** | 网格路径搜索、不重复使用、存在性判断 |
| 💡 **延伸思考** | 若允许多次使用？→ 需改用 visited 数组；若找所有路径？→ 收集结果而非提前返回 |

此题是 **回溯算法的经典模板题**，掌握后可轻松应对类似如「岛屿数量」「N皇后」「解数独」等 LeetCode 高频题。
