# 84. 柱状图中最大的矩形

[LeetCode 题目链接](https://leetcode.cn/problems/largest-rectangle-in-histogram?envType=problem-list-v2&envId=2cktkvj)

## 📌 题目描述

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

## 📌 示例说明

**示例 1：**

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

![示例1图示](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

**示例 2：**

```
输入：heights = [2,4]
输出：4
```

## 💡 解题思路

### 方法一：暴力法（超时）

对每个柱子，向左右扩展找到能形成的最大矩形：

- 对于每个位置 i，以 heights[i] 为高度
- 向左找到第一个小于 heights[i] 的位置 left
- 向右找到第一个小于 heights[i] 的位置 right
- 矩形宽度为 (right - left - 1)，面积为 heights[i] * width

**时间复杂度：O(n²)**，对于 n=10⁵ 会超时。

______________________________________________________________________

### 方法二：单调栈（推荐 ✅）

**核心思想**：使用单调递增栈来高效找到每个柱子左右边界。

#### 步骤详解：

1. **初始化**：创建一个单调递增栈，存储数组下标
1. **遍历数组**：
   - 如果当前高度 >= 栈顶高度，入栈
   - 如果当前高度 < 栈顶高度，说明找到了栈顶元素的右边界
1. **计算面积**：
   - 弹出栈顶元素作为矩形高度
   - 新的栈顶元素是左边界（如果栈为空，左边界为 -1）
   - 右边界是当前元素下标
   - 宽度 = 右边界 - 左边界 - 1
1. **处理剩余元素**：遍历完成后，栈中剩余元素的右边界为 n

#### 优化技巧：

- 在原数组前后添加 0，避免边界判断
- 前面加 0 确保栈不为空，后面加 0 确保所有元素都能被处理

______________________________________________________________________

### 方法三：分治法（了解即可）

- 找到最小高度的位置，最大矩形要么在左边，要么在右边，要么跨越最小值
- 递归处理左右子数组
- **时间复杂度**：最好 O(n log n)，最坏 O(n²)

______________________________________________________________________

### 方法四：动态规划（预处理左右边界）

- 预处理每个位置的左边界和右边界
- left[i] 表示 i 左边第一个小于 heights[i] 的位置
- right[i] 表示 i 右边第一个小于 heights[i] 的位置
- **时间复杂度**：O(n)，**空间复杂度**：O(n)

## 💻 代码实现

```java
import java.util.*;

public class Solution {
    // 方法二：单调栈（优化版本）
    public int largestRectangleArea(int[] heights) {
        // 在原数组前后添加0，简化边界处理
        int[] newHeights = new int[heights.length + 2];
        System.arraycopy(heights, 0, newHeights, 1, heights.length);
        
        Deque<Integer> stack = new ArrayDeque<>();
        int maxArea = 0;
        
        for (int i = 0; i < newHeights.length; i++) {
            // 当前高度小于栈顶高度时，计算以栈顶为高的矩形面积
            while (!stack.isEmpty() && newHeights[i] < newHeights[stack.peek()]) {
                int height = newHeights[stack.pop()];
                int width = i - stack.peek() - 1;
                maxArea = Math.max(maxArea, height * width);
            }
            stack.push(i);
        }
        
        return maxArea;
    }
    
    // 方法四：动态规划（预处理左右边界）
    public int largestRectangleAreaDP(int[] heights) {
        int n = heights.length;
        if (n == 0) return 0;
        
        int[] left = new int[n];  // left[i] 表示i左边第一个小于heights[i]的位置
        int[] right = new int[n]; // right[i] 表示i右边第一个小于heights[i]的位置
        
        // 计算left数组
        left[0] = -1;
        for (int i = 1; i < n; i++) {
            int j = i - 1;
            while (j >= 0 && heights[j] >= heights[i]) {
                j = left[j]; // 跳跃优化
            }
            left[i] = j;
        }
        
        // 计算right数组
        right[n - 1] = n;
        for (int i = n - 2; i >= 0; i--) {
            int j = i + 1;
            while (j < n && heights[j] >= heights[i]) {
                j = right[j]; // 跳跃优化
            }
            right[i] = j;
        }
        
        // 计算最大面积
        int maxArea = 0;
        for (int i = 0; i < n; i++) {
            maxArea = Math.max(maxArea, heights[i] * (right[i] - left[i] - 1));
        }
        
        return maxArea;
    }
}
```

```go
// 方法二：单调栈（优化版本）
func largestRectangleArea(heights []int) int {
    // 在原数组前后添加0，简化边界处理
    newHeights := make([]int, len(heights)+2)
    copy(newHeights[1:], heights)
    
    stack := []int{}
    maxArea := 0
    
    for i := 0; i < len(newHeights); i++ {
        // 当前高度小于栈顶高度时，计算以栈顶为高的矩形面积
        for len(stack) > 0 && newHeights[i] < newHeights[stack[len(stack)-1]] {
            height := newHeights[stack[len(stack)-1]]
            stack = stack[:len(stack)-1]
            width := i - stack[len(stack)-1] - 1
            if height*width > maxArea {
                maxArea = height * width
            }
        }
        stack = append(stack, i)
    }
    
    return maxArea
}

// 方法四：动态规划（预处理左右边界）
func largestRectangleAreaDP(heights []int) int {
    n := len(heights)
    if n == 0 {
        return 0
    }
    
    left := make([]int, n)   // left[i] 表示i左边第一个小于heights[i]的位置
    right := make([]int, n)  // right[i] 表示i右边第一个小于heights[i]的位置
    
    // 计算left数组
    left[0] = -1
    for i := 1; i < n; i++ {
        j := i - 1
        for j >= 0 && heights[j] >= heights[i] {
            j = left[j] // 跳跃优化
        }
        left[i] = j
    }
    
    // 计算right数组
    right[n-1] = n
    for i := n - 2; i >= 0; i-- {
        j := i + 1
        for j < n && heights[j] >= heights[i] {
            j = right[j] // 跳跃优化
        }
        right[i] = j
    }
    
    // 计算最大面积
    maxArea := 0
    for i := 0; i < n; i++ {
        area := heights[i] * (right[i] - left[i] - 1)
        if area > maxArea {
            maxArea = area
        }
    }
    
    return maxArea
}
```

## 🎯 示例演示

以 `heights = [2,1,5,6,2,3]` 为例：

| 步骤 | 当前索引 | 栈状态 | 处理说明 |
|------|----------|--------|----------|
| 0 | 0 (newHeights[0]=0) | [0] | 入栈 |
| 1 | 1 (newHeights[1]=2) | [0,1] | 2>0，入栈 |
| 2 | 2 (newHeights[2]=1) | [0,2] | 1\<2，弹出1，计算面积：2×(2-0-1)=2 |
| 3 | 3 (newHeights[3]=5) | [0,2,3] | 5>1，入栈 |
| 4 | 4 (newHeights[4]=6) | [0,2,3,4] | 6>5，入栈 |
| 5 | 5 (newHeights[5]=2) | [0,2,5] | 2\<6，弹出4，面积：6×(5-3-1)=6；2\<5，弹出3，面积：5×(5-2-1)=10 |
| 6 | 6 (newHeights[6]=3) | [0,2,5,6] | 3>2，入栈 |
| 7 | 7 (newHeights[7]=0) | [0] | 依次弹出并计算，最终得到最大面积10 |

## ✅ 答案有效性证明

**单调栈方法的正确性**：

1. **完备性**：每个柱子都会被作为矩形高度计算一次
1. **最优性**：对于每个柱子，我们找到了以其为高度的最大可能矩形
1. **边界正确性**：通过在数组两端添加0，确保了所有元素都能被正确处理
1. **单调性保证**：栈中始终保持递增顺序，确保每次弹出时都能正确计算面积

**关键观察**：最大矩形必然以某个柱子的高度为高，因此枚举每个柱子作为高度是完备的。

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|------------|------------|------|
| ❌ 暴力法 | O(n²) | O(1) | 超时 |
| ✅ 单调栈 | O(n) | O(n) | **推荐**，每个元素入栈出栈各一次 |
| ⚠️ 分治法 | O(n log n) ~ O(n²) | O(n) | 最坏情况退化为O(n²) |
| ✅ 动态规划 | O(n) | O(n) | 需要额外空间存储左右边界 |

## 📝 问题总结

- **核心洞察**：最大矩形必然以某个柱子的高度为高
- **关键技术**：单调栈用于高效找到每个元素的左右边界
- **优化技巧**：在数组两端添加哨兵值（0）简化边界处理
- **实际应用**：类似问题包括接雨水、最大矩形等，都可使用单调栈解决

💡 **记忆要点**：遇到"下一个更大/更小元素"、"以某元素为边界的最大/最小值"等问题，优先考虑单调栈！
