#  96. 不同的二叉搜索树

## 🔗 问题简介

[LeetCode 96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees?envType=problem-list-v2&envId=2cktkvj)

### 📝 题目描述

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

______________________________________________________________________

## 🧪 示例说明

**示例 1：**

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1
```

**图示（n = 3）：**

对于 n = 3，有以下 5 种不同的 BST：

```
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
```

______________________________________________________________________

## 💡 解题思路

### 方法一：动态规划（DP）

#### 思路分析

- 二叉搜索树（BST）的性质：左子树所有节点 < 根节点 < 右子树所有节点。

- 对于 `n` 个节点（值为 1~n），我们可以选择任意一个节点 `i` 作为根节点：

  - 左子树包含 `i-1` 个节点（1 ~ i-1）
  - 右子树包含 `n-i` 个节点（i+1 ~ n）

- 因此，以 `i` 为根的 BST 数量 = 左子树数量 × 右子树数量。

- 设 `dp[i]` 表示 `i` 个节点能组成的 BST 数量，则：

  $$
  dp[n] = \\sum\_{i=1}^{n} dp[i-1] \\times dp[n-i]
  $$

- 初始条件：`dp[0] = 1`（空树也算一种），`dp[1] = 1`

> 这实际上就是 **卡特兰数（Catalan Number）** 的递推公式！

#### 步骤

1. 初始化 `dp[0] = 1`, `dp[1] = 1`
1. 对于 `i` 从 2 到 `n`：
   - 遍历 `j` 从 1 到 `i`（`j` 为根）
   - `dp[i] += dp[j-1] * dp[i-j]`
1. 返回 `dp[n]`

______________________________________________________________________

### 方法二：数学公式（卡特兰数）

卡特兰数第 `n` 项公式：

$$
C_n = \\frac{1}{n+1} \\binom{2n}{n} = \\frac{(2n)!}{(n+1)!n!}
$$

也可以用递推形式避免大数阶乘：

$$
C_0 = 1,\\quad C\_{n+1} = \\frac{2(2n+1)}{n+2} C_n
$$

> 但需注意整数除法精度问题，建议用 long 并确保整除。

______________________________________________________________________

## 💻 代码实现

```java
// 方法一：动态规划
class Solution {
    public int numTrees(int n) {
        int[] dp = new int[n + 1];
        dp[0] = 1;
        dp[1] = 1;
        
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
}

// 方法二：卡特兰数（数学公式）
class Solution {
    public int numTrees(int n) {
        long catalan = 1;
        for (int i = 0; i < n; i++) {
            catalan = catalan * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) catalan;
    }
}
```

```go
// 方法一：动态规划
func numTrees(n int) int {
    dp := make([]int, n+1)
    dp[0], dp[1] = 1, 1
    
    for i := 2; i <= n; i++ {
        for j := 1; j <= i; j++ {
            dp[i] += dp[j-1] * dp[i-j]
        }
    }
    return dp[n]
}

// 方法二：卡特兰数（数学公式）
func numTrees(n int) int {
    catalan := int64(1)
    for i := 0; i < n; i++ {
        catalan = catalan * 2 * int64(2*i+1) / int64(i+2)
    }
    return int(catalan)
}
```

______________________________________________________________________

## 🎯 示例演示（n = 3）

| i（总节点数） | j（根节点） | 左子树节点数 | 右子树节点数 | 贡献数量（dp[left] * dp[right]） |
|---------------|-------------|----------------|----------------|-------------------------------|
| 3 | 1 | 0 | 2 | dp[0] * dp[2] = 1 * 2 = 2 |
| 3 | 2 | 1 | 1 | dp[1] * dp[1] = 1 * 1 = 1 |
| 3 | 3 | 2 | 0 | dp[2] * dp[0] = 2 * 1 = 2 |
| **总计** | — | — | — | **2 + 1 + 2 = 5** ✅ |

其中 `dp[2] = dp[0]*dp[1] + dp[1]*dp[0] = 1 + 1 = 2`

______________________________________________________________________

## ✅ 答案有效性证明

- **正确性**：基于 BST 的结构性质和分治思想，所有可能的根都被枚举，左右子树独立组合，无重复无遗漏。
- **边界处理**：`dp[0] = 1` 是关键，表示空子树有一种结构（空树），这是组合数学中的标准约定。
- **与卡特兰数一致**：已知 n 个节点的不同 BST 数量即为第 n 个卡特兰数，两种方法结果一致。

______________________________________________________________________

## 📊 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 |
|--------------|----------------|--------------|
| 动态规划 | O(n²) | O(n) |
| 卡特兰公式 | O(n) | O(1) |

> 推荐在面试中先写 DP 解法（思路清晰），再提优化到数学公式。

______________________________________________________________________

## 📌 问题总结

- 本题是 **卡特兰数** 的经典应用场景之一。
- 核心在于理解：**固定根后，左右子树独立，总数为乘积**。
- 动态规划状态转移方程体现了“分而治之”的思想。
- 扩展思考：若要求生成所有不同的 BST（LeetCode 95 题），则需回溯构造，而非仅计数。

> 💡 **记忆点**：看到“不同结构的二叉搜索树数量”，立刻联想到 **卡特兰数**！
